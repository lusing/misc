"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _function = require("./function");
"use strict";var _collection = require("./collection");
"use strict";var _conversion = require("./conversion");
"use strict";// TODO: Move to proper files and exposevar callUnless = function callUnless(check) {  return function (failFn) {    return function (fn) {      return function (x, y) {        return check(x) ? failFn(y) : check(y) ? failFn(x) : fn(x, y);      };    };  };};
"use strict";var callUnlessEmpty = callUnless(_fp.default.isEmpty);
"use strict";var wrapArray = function wrapArray(x) {  return [x];};
"use strict";var callUnlessEmptyArray = callUnlessEmpty(wrapArray);
"use strict";var dropRight = _fp.default.dropRight(1);
"use strict";var last = _fp.default.takeRight(1); // Arrays// ------
"use strict";// Arrays// ------var compactJoin = _fp.default.curry(function (join, x) {  return _fp.default.compact(x).join(join);});
"use strict";var dotJoin = compactJoin('.');
"use strict";var dotJoinWith = function dotJoinWith(fn) {  return function (x) {    return _fp.default.filter(fn, x).join('.');  };};
"use strict";var repeated = _fp.default.flow(_fp.default.groupBy(function (e) {  return e;}), _fp.default.filter(function (e) {  return e.length > 1;}), _fp.default.flatten, _fp.default.uniq);
"use strict";var push = _fp.default.curry(function (val, arr) {  return arr.concat([val]);});
"use strict";var pushIn = _fp.default.curry(function (arr, val) {  return arr.concat([val]);});
"use strict";var pushOn = _fp.default.curry(function (arr, val) {  arr.push(val);  return arr;});
"use strict";var moveIndex = function moveIndex(from, to, arr) {  return _fp.default.flow(_fp.default.pullAt(from), (0, _collection.insertAtIndex)(to, arr[from]))(arr);};
"use strict";var overlaps = function overlaps(x, y) {  return y[0] > x[1];};
"use strict";var mergeRange = function mergeRange(x, y) {  return [[x[0], _fp.default.max(x.concat(y))]];};
"use strict";var actuallMergeRanges = callUnlessEmptyArray(function (x, y) {  return overlaps(x, y) ? [x, y] : mergeRange(x, y);});
"use strict";var mergeRanges = _fp.default.flow(_fp.default.sortBy([0, 1]), _fp.default.reduce(function (result, range) {  return dropRight(result).concat(actuallMergeRanges(_fp.default.flatten(last(result)), range));}, [])); // [a, b...] -> a -> b
"use strict";// [a, b...] -> a -> bvar cycle = _fp.default.curry(function (a, n) {  return a[(a.indexOf(n) + 1) % a.length];});
"use strict";var arrayToObject = _fp.default.curry(function (k, v, a) {  return _fp.default.flow(_fp.default.keyBy(k), _fp.default.mapValues(v))(a);}); // zipObject that supports functions instead of objects
"use strict";// zipObject that supports functions instead of objectsvar zipObjectDeepWith = _fp.default.curry(function (x, y) {  return _fp.default.zipObjectDeep(x, _fp.default.isFunction(y) && _fp.default.isArray(x) ? _fp.default.times(y, x.length) : y);});
"use strict";var flags = zipObjectDeepWith(_fp.default, function () {  return true;});
"use strict";var prefixes = function prefixes(list) {  return _fp.default.range(1, list.length + 1).map(function (x) {    return _fp.default.take(x, list);  });};
"use strict";var encoder = function encoder(separator) {  return {    encode: compactJoin(separator),    decode: _fp.default.split(separator)  };};
"use strict";var dotEncoder = encoder('.');
"use strict";var slashEncoder = encoder('/');
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var chunkBy = _fp.default.curry(function (f, array) {  return _fp.default.isEmpty(array) ? [] : _fp.default.reduce(function (acc, x) {    return f(_fp.default.last(acc), x) ? [].concat(_toConsumableArray(_fp.default.initial(acc)), [[].concat(_toConsumableArray(_fp.default.last(acc)), [x])]) : [].concat(_toConsumableArray(acc), [[x]]);  }, [[_fp.default.head(array)]], _fp.default.tail(array));});
"use strict";var toggleElementBy = _fp.default.curry(function (check, val, arr) {  return ((0, _function.callOrReturn)(check, val, arr) ? _fp.default.pull : push)(val, arr);});
"use strict";var toggleElement = toggleElementBy(_fp.default.includes);
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var intersperse = _fp.default.curry(function (f, _ref) {  var _ref2 = _toArray(_ref),      x0 = _ref2[0],      xs = _ref2.slice(1);  return (0, _conversion.reduceIndexed)(function (acc, x, i) {    return i === xs.length ? [].concat(_toConsumableArray(acc), [x]) : [].concat(_toConsumableArray(acc), [(0, _function.callOrReturn)(f, acc, i, xs), x]);  }, [x0], xs);});
"use strict";function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _toArray(_ref2),    x0 = _ref3[0],    xs = _ref3.slice(1);
"use strict";var replaceElementBy = _fp.default.curry(function (f, b, arr) {  return _fp.default.map(function (c) {    return f(c) ? b : c;  }, arr);});
"use strict";var replaceElement = _fp.default.curry(function (a, b, arr) {  return replaceElementBy(_fp.default.isEqual(a), b, arr);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _tree = require("./tree");
"use strict";var flowMap = function flowMap() {  var _fp$default;  return _fp.default.map((_fp$default = _fp.default).flow.apply(_fp$default, arguments));};
"use strict";var findApply = _fp.default.curry(function (f, arr) {  return _fp.default.iteratee(f)(_fp.default.find(f, arr));}); // Algebras// --------// A generic map that works for plain objects and arrays
"use strict";// Algebras// --------// A generic map that works for plain objects and arraysvar map = _fp.default.curry(function (f, x) {  return (_fp.default.isArray(x) ? _fp.default.map : _fp.default.mapValues).convert({    cap: false  })(f, x);}); // Map for any recursive algebraic data structure// defaults in multidimensional arrays and recursive plain objects
"use strict";// Map for any recursive algebraic data structure// defaults in multidimensional arrays and recursive plain objectsvar deepMap = _fp.default.curry(function (fn, obj) {  var _map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : map;  var is = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tree.isTraversable;  return _map(function (e) {    return is(e) ? deepMap(fn, fn(e), _map, is) : e;  }, obj);});
"use strict";var _map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : map;
"use strict";var is = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tree.isTraversable;
"use strict";var insertAtStringIndex = function insertAtStringIndex(index, val, str) {  return str.slice(0, index) + val + str.slice(index);};
"use strict";var insertAtArrayIndex = function insertAtArrayIndex(index, val, arr) {  var result = _fp.default.clone(arr);  result.splice(index, 0, val);  return result;};
"use strict";var result = _fp.default.clone(arr);
"use strict";var insertAtIndex = _fp.default.curry(function (index, val, collection) {  return _fp.default.isString(collection) ? insertAtStringIndex(index, val, collection) : insertAtArrayIndex(index, val, collection);});
"use strict";var compactMap = _fp.default.curry(function (fn, collection) {  return _fp.default.flow(_fp.default.map(fn), _fp.default.compact)(collection);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";// (fn, a, b) -> fn(a, b)var maybeCall = function maybeCall(fn) {  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    args[_key - 1] = arguments[_key];  }  return _fp.default.isFunction(fn) && fn.apply(void 0, args);}; // (fn, a, b) -> fn(a, b)
"use strict";var _len = arguments.length,    args = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// (fn, a, b) -> fn(a, b)var callOrReturn = function callOrReturn(fn) {  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {    args[_key2 - 1] = arguments[_key2];  }  return _fp.default.isFunction(fn) ? fn.apply(void 0, args) : fn;}; // (a, Monoid f) -> f[a] :: f a
"use strict";var _len2 = arguments.length,    args = new Array(_len2 > 1 ? _len2 - 1 : 0),    _key2 = 1;
"use strict";// (a, Monoid f) -> f[a] :: f avar boundMethod = function boundMethod(method, object) {  return object[method].bind(object);}; // http://ramdajs.com/docs/#converge
"use strict";// http://ramdajs.com/docs/#convergevar converge = function converge(converger, branches) {  return function () {    return converger(_fp.default.over(branches).apply(void 0, arguments));  };};
"use strict";var composeApply = function composeApply(f, g) {  return function (x) {    return f(g(x))(x);  };};
"use strict";var comply = composeApply; // Prettier version of `defer` the one from bluebird docs
"use strict";// Prettier version of `defer` the one from bluebird docsvar defer = function defer() {  var resolve;  var reject;  var promise = new Promise(function (res, rej) {    resolve = res;    reject = rej;  });  return {    resolve,    reject,    promise  };}; // `_.debounce` for async functions, which require consistently returning a single promise for all queued calls
"use strict";var resolve;
"use strict";var reject;
"use strict";var promise = new Promise(function (res, rej) {  resolve = res;  reject = rej;});
"use strict";// `_.debounce` for async functions, which require consistently returning a single promise for all queued callsvar debounceAsync = function debounceAsync(n, f) {  var deferred = defer();  var debounced = _fp.default.debounce(n, function () {    deferred.resolve(f.apply(void 0, arguments));    deferred = defer();  });  return function () {    debounced.apply(void 0, arguments);    return deferred.promise;  };};
"use strict";var deferred = defer();
"use strict";var debounced = _fp.default.debounce(n, function () {  deferred.resolve(f.apply(void 0, arguments));  deferred = defer();});
"use strict";var currier = function currier(f) {  return function () {    for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {      fns[_key3] = arguments[_key3];    }    return _fp.default.curryN(fns[0].length, f.apply(void 0, fns));  };}; // (f1, f2, ...fn) -> f1Args1 -> f1Arg2 -> ...f1ArgN -> fn(f2(f1))
"use strict";var _len3 = arguments.length,    fns = new Array(_len3),    _key3 = 0;
"use strict";// (f1, f2, ...fn) -> f1Args1 -> f1Arg2 -> ...f1ArgN -> fn(f2(f1))var flurry = currier(_fp.default.flow); // like _.overArgs, but on all args
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }// like _.overArgs, but on all argsvar mapArgs = _fp.default.curry(function (mapper, fn) {  return function () {    for (var _len4 = arguments.length, x = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {      x[_key4] = arguments[_key4];    }    return fn.apply(void 0, _toConsumableArray(x.map(mapper)));  };});
"use strict";var _len4 = arguments.length,    x = new Array(_len4),    _key4 = 0;
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var differentLast = function differentLast(normalCase, lastCase) {  return function (acc, i, list) {    return i === list.length - 1 ? _fp.default.iteratee(lastCase)(acc, i, list) : _fp.default.iteratee(normalCase)(acc, i, list);  };};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _array = require("./array");
"use strict";var _logic = require("./logic");
"use strict";// Stubsvar functionLens = function functionLens(val) {  return function () {    if (!arguments.length) return val;    val = arguments.length <= 0 ? undefined : arguments[0];  };};
"use strict";var objectLens = function objectLens(val) {  return {    get: function get() {      return val;    },    set(x) {      val = x;    }  };}; // Lens Conversion
"use strict";// Lens Conversionvar fnToObj = function fnToObj(fn) {  return {    get: fn,    set: fn  };};
"use strict";var objToFn = function objToFn(lens) {  return function () {    return arguments.length ? lens.set(arguments.length <= 0 ? undefined : arguments[0]) : lens.get();  };}; // Lens Construction
"use strict";// Lens Constructionvar lensProp = function lensProp(field, source) {  return {    get: function get() {      return _fp.default.get(field, source);    },    //source[field],    set(value) {      (0, _conversion.setOn)(field, value, source); // source[field] = value    }  };}; // NOTE: This used to use mapValues; however, doing so would sometimes cause issues// in some edge cases like trying to lens state coming from an inject function// in the mobx library. It would inadvertently cause the inject to re-run.// Using reduce here alleviates that issue.
"use strict";// NOTE: This used to use mapValues; however, doing so would sometimes cause issues// in some edge cases like trying to lens state coming from an inject function// in the mobx library. It would inadvertently cause the inject to re-run.// Using reduce here alleviates that issue.var lensOf = function lensOf(object) {  return _fp.default.reduce(function (res, key) {    res[key] = lensProp(key, object);    return res;  }, {}, _fp.default.keys(object));};
"use strict";var includeLens = function includeLens(value) {  for (var _len = arguments.length, lens = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    lens[_key - 1] = arguments[_key];  }  return {    get: function get() {      return _fp.default.includes(value, view.apply(void 0, lens));    },    // Uniq is to ensure multiple calls to set(true) don't push multiple times since this is about membership of a set    set: function (_set) {      function set(_x) {        return _set.apply(this, arguments);      }      set.toString = function () {        return _set.toString();      };      return set;    }(function (x) {      return set.apply(void 0, [_fp.default.uniq((0, _array.toggleElementBy)(!x, value, view.apply(void 0, lens)))].concat(lens));    })  };}; // Lens Manipulation//let construct = (...lens) => (lens[1] ? lensProp(...lens) : lens[0])
"use strict";var _len = arguments.length,    lens = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// Lens Manipulation//let construct = (...lens) => (lens[1] ? lensProp(...lens) : lens[0])var lensPair = function lensPair(get, set) {  return {    get,    set  };};
"use strict";var construct = function construct() {  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {    args[_key2] = arguments[_key2];  }  return args[1] ? _fp.default.every(_fp.default.isFunction, args) ? lensPair.apply(void 0, args) : lensProp.apply(void 0, args) : (0, _logic.when)(_fp.default.isArray, stateLens)(args[0]);};
"use strict";var _len2 = arguments.length,    args = new Array(_len2),    _key2 = 0;
"use strict";var read = function read(lens) {  return lens.get ? lens.get() : lens();};
"use strict";var view = function view() {  return read(construct.apply(void 0, arguments));};
"use strict";var views = function views() {  for (var _len3 = arguments.length, lens = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {    lens[_key3] = arguments[_key3];  }  return function () {    return view.apply(void 0, lens);  };};
"use strict";var _len3 = arguments.length,    lens = new Array(_len3),    _key3 = 0;
"use strict";var write = function write(val, lens) {  return lens.set ? lens.set(val) : lens(val);};
"use strict";var set = _fp.default.curryN(2, function (val) {  for (var _len4 = arguments.length, lens = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {    lens[_key4 - 1] = arguments[_key4];  }  return write(val, construct.apply(void 0, lens));});
"use strict";var _len4 = arguments.length,    lens = new Array(_len4 > 1 ? _len4 - 1 : 0),    _key4 = 1;
"use strict";var sets = _fp.default.curryN(2, function (val) {  for (var _len5 = arguments.length, lens = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {    lens[_key5 - 1] = arguments[_key5];  }  return function () {    return set.apply(void 0, [val].concat(lens));  };});
"use strict";var _len5 = arguments.length,    lens = new Array(_len5 > 1 ? _len5 - 1 : 0),    _key5 = 1;
"use strict";var setsWith = _fp.default.curry(function (f) {  for (var _len6 = arguments.length, lens = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {    lens[_key6 - 1] = arguments[_key6];  }  return function (x) {    return set.apply(void 0, [_fp.default.iteratee(f)(x)].concat(lens));  };});
"use strict";var _len6 = arguments.length,    lens = new Array(_len6 > 1 ? _len6 - 1 : 0),    _key6 = 1;
"use strict";var flip = function flip() {  for (var _len7 = arguments.length, lens = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {    lens[_key7] = arguments[_key7];  }  return function () {    return set.apply(void 0, [!view.apply(void 0, lens)].concat(lens));  };};
"use strict";var _len7 = arguments.length,    lens = new Array(_len7),    _key7 = 0;
"use strict";var on = sets(true);
"use strict";var off = sets(false); // Lens Consumption// Map lens to dom event handlers
"use strict";// Lens Consumption// Map lens to dom event handlersvar binding = function binding(value, getEventValue) {  return function () {    for (var _len8 = arguments.length, lens = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {      lens[_key8] = arguments[_key8];    }    return {      [value]: view.apply(void 0, lens),      onChange: setsWith.apply(void 0, [getEventValue].concat(lens))    };  };}; // Dom events have relevent fields on the `target` property of event objects
"use strict";var _len8 = arguments.length,    lens = new Array(_len8),    _key8 = 0;
"use strict";// Dom events have relevent fields on the `target` property of event objectsvar targetBinding = function targetBinding(field) {  return binding(field, (0, _logic.when)(_fp.default.hasIn("target.".concat(field)), _fp.default.get("target.".concat(field))));};
"use strict";var domLens = {  value: targetBinding('value'),  checkboxValues: _fp.default.flow(includeLens, targetBinding('checked')),  hover: function hover() {    return {      onMouseEnter: on.apply(void 0, arguments),      onMouseLeave: off.apply(void 0, arguments)    };  },  focus: function focus() {    return {      onFocus: on.apply(void 0, arguments),      onBlur: off.apply(void 0, arguments)    };  },  targetBinding,  binding};
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var stateLens = function stateLens(_ref) {  var _ref2 = _slicedToArray(_ref, 2),      value = _ref2[0],      set = _ref2[1];  return {    get: function get() {      return value;    },    set  };};
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _slicedToArray(_ref2, 2),    value = _ref3[0],    set = _ref3[1];
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _array = require("./array");
"use strict";var _logic = require("./logic");
"use strict";var _lang = require("./lang");
"use strict";var _conversion = require("./conversion");
"use strict";var _collection = require("./collection");
"use strict";var _aspect = require("./aspect");
"use strict";var _function = require("./function");
"use strict";var noCap = _fp.default.convert({  cap: false}); // (k, v) -> {k: v}
"use strict";// (k, v) -> {k: v}var singleObject = _fp.default.curry(function (key, value) {  return {    [key]: value  };});
"use strict";var singleObjectR = _fp.default.flip(singleObject); // Formerly objToObjArr// ({a, b}) -> [{a}, {b}]
"use strict";// Formerly objToObjArr// ({a, b}) -> [{a}, {b}]var chunkObject = function chunkObject(value) {  return _fp.default.isArray(value) ? value : _fp.default.map(_fp.default.spread(singleObject), _fp.default.toPairs(value));}; // Remove properties with falsey values: ({ a: 1, b: null, c: false}) -> {a:1}
"use strict";// Remove properties with falsey values: ({ a: 1, b: null, c: false}) -> {a:1}var compactObject = _fp.default.pickBy(_fp.default.identity);
"use strict";var isEmptyObject = _fp.default.isEqual({});
"use strict";var isNotEmptyObject = _fp.default.negate(isEmptyObject); // { a:1, b:{}, c:2 } -> { a:1, c:2 }
"use strict";// { a:1, b:{}, c:2 } -> { a:1, c:2 }var stripEmptyObjects = _fp.default.pickBy(isNotEmptyObject); // const crazyBS = (f, g) => (a, b) => f(a)(g(b))// { a: { b: 1, c: 2 } }, [ 'b' ] -> { a: { b: 1 } }
"use strict";// const crazyBS = (f, g) => (a, b) => f(a)(g(b))// { a: { b: 1, c: 2 } }, [ 'b' ] -> { a: { b: 1 } }var pickInto = function pickInto(map, source) {  return _fp.default.mapValues((0, _conversion.pickIn)(source), map);};
"use strict";var renameProperty = _fp.default.curry(function (from, to, target) {  return _fp.default.has(from, target) ? _fp.default.flow(function (x) {    return _fp.default.set(to, _fp.default.get(from, x), x);  }, _fp.default.unset(from))(target) : target;}); // { x:['a','b'], y:1 } -> [{ x:'a', y:1 }, { x:'b', y:1 }] just like mongo's `$unwind`
"use strict";// { x:['a','b'], y:1 } -> [{ x:'a', y:1 }, { x:'b', y:1 }] just like mongo's `$unwind`var unwind = _fp.default.curry(function (prop, x) {  return (0, _logic.ifElse)(_fp.default.isArray, _fp.default.map(function (y) {    return _fp.default.set(prop, y, x);  }), _fp.default.stubArray, _fp.default.get(prop, x));}); // this one's _actually_ just like mongo's `$unwind`
"use strict";// this one's _actually_ just like mongo's `$unwind`var unwindArray = _fp.default.curry(function (prop, xs) {  return _fp.default.flatMap(unwind(prop))(xs);});
"use strict";var isFlatObject = (0, _logic.overNone)([_fp.default.isPlainObject, _fp.default.isArray]); // { a: { b: { c: 1 } } } => { 'a.b.c' : 1 }
"use strict";// { a: { b: { c: 1 } } } => { 'a.b.c' : 1 }var flattenObject = function flattenObject(input, paths) {  return (0, _conversion.reduceIndexed)(function (output, value, key) {    return _fp.default.merge(output, (isFlatObject(value) ? singleObjectR : flattenObject)(value, (0, _array.dotJoinWith)(_lang.isNotNil)([paths, key])));  }, {}, input);}; // { 'a.b.c' : 1 } => { a: { b: { c: 1 } } }
"use strict";// { 'a.b.c' : 1 } => { a: { b: { c: 1 } } }var unflattenObject = function unflattenObject(x) {  return _fp.default.zipObjectDeep(_fp.default.keys(x), _fp.default.values(x));}; // Returns true if object keys are only elements from signature list (but does not require all signature keys to be present)
"use strict";// Returns true if object keys are only elements from signature list (but does not require all signature keys to be present)var matchesSignature = _fp.default.curry(function (signature, value) {  return _fp.default.isObject(value) && !_fp.default.difference(_fp.default.keys(value), signature).length;}); // `_.matches` that returns true if one or more of the conditions match instead of all
"use strict";// `_.matches` that returns true if one or more of the conditions match instead of allvar matchesSome = _fp.default.flow(chunkObject, _fp.default.map(_fp.default.matches), _fp.default.overSome); // Checks if a property deep in a given item equals to a given value
"use strict";// Checks if a property deep in a given item equals to a given valuevar compareDeep = _fp.default.curry(function (path, item, value) {  return _fp.default.get(path, item) === value;}); //Depreacted in favor of _.update version from lodash
"use strict";//Depreacted in favor of _.update version from lodashvar mapProp = _aspect.aspects.deprecate('mapProp', '1.46.0', '_.update')(noCap.update); // `_.get` that returns the target object if lookup fails
"use strict";// `_.get` that returns the target object if lookup failsvar getOrReturn = _fp.default.curry(function (prop, x) {  return _fp.default.getOr(x, prop, x);}); // `_.get` that returns the prop if lookup fails
"use strict";// `_.get` that returns the prop if lookup failsvar alias = _fp.default.curry(function (prop, x) {  return _fp.default.getOr(prop, prop, x);}); // flipped alias
"use strict";// flipped aliasvar aliasIn = _fp.default.curry(function (x, prop) {  return _fp.default.getOr(prop, prop, x);}); // A `_.get` that takes an array of paths and returns the value at the first path that matches
"use strict";// A `_.get` that takes an array of paths and returns the value at the first path that matchesvar cascade = _fp.default.curryN(2, function (paths, obj, defaultValue) {  return _fp.default.flow((0, _collection.findApply)(function (x) {    return x && _fp.default.iteratee(x)(obj);  }), _fp.default.defaultTo(defaultValue))(paths);}); // Flipped cascade
"use strict";// Flipped cascadevar cascadeIn = _fp.default.curryN(2, function (obj, paths, defaultValue) {  return cascade(paths, obj, defaultValue);}); // A `_.get` that takes an array of paths and returns the first path that matched
"use strict";// A `_.get` that takes an array of paths and returns the first path that matchedvar cascadeKey = _fp.default.curry(function (paths, obj) {  return _fp.default.find((0, _conversion.getIn)(obj), paths);}); // A `_.get` that takes an array of paths and returns the first path that exists
"use strict";// A `_.get` that takes an array of paths and returns the first path that existsvar cascadePropKey = _fp.default.curry(function (paths, obj) {  return _fp.default.find((0, _conversion.hasIn)(obj), paths);}); // A `_.get` that takes an array of paths and returns the first value that has an existing path
"use strict";// A `_.get` that takes an array of paths and returns the first value that has an existing pathvar cascadeProp = _fp.default.curry(function (paths, obj) {  return _fp.default.get(cascadePropKey(paths, obj), obj);});
"use strict";var unkeyBy = _fp.default.curry(function (keyName, obj) {  return (0, _conversion.mapIndexed)(function (val, key) {    return _fp.default.extend(val, {      [keyName || key]: key    });  })(obj);});
"use strict";var simpleDiff = function simpleDiff(original, deltas) {  var o = flattenObject(original);  return _fp.default.flow(flattenObject, (0, _conversion.mapValuesIndexed)(function (to, field) {    return {      from: o[field],      to    };  }), _fp.default.omitBy(function (x) {    return _fp.default.isEqual(x.from, x.to);  }))(deltas);};
"use strict";var o = flattenObject(original);
"use strict";var simpleDiffArray = _fp.default.flow(simpleDiff, unkeyBy('field'));
"use strict";var diff = function diff(original, deltas) {  var o = flattenObject(original);  var d = flattenObject(deltas);  return _fp.default.flow((0, _conversion.mapValuesIndexed)(function (_, field) {    return {      from: o[field],      to: d[field]    };  }), _fp.default.omitBy(function (x) {    return _fp.default.isEqual(x.from, x.to);  }))(_fp.default.merge(o, d));};
"use strict";var o = flattenObject(original);
"use strict";var d = flattenObject(deltas);
"use strict";var diffArray = _fp.default.flow(diff, unkeyBy('field')); // A `_.pick` that mutates the object
"use strict";// A `_.pick` that mutates the objectvar pickOn = function pickOn() {  var paths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];  var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};  return _fp.default.flow(_fp.default.keys, _fp.default.map(function (key) {    if (!_fp.default.includes(key, paths)) {      delete obj[key];    }  }))(obj);};
"use strict";var paths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
"use strict";var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
"use strict";var mergeArrays = function mergeArrays(objValue, srcValue) {  return _fp.default.isArray(objValue) ? objValue.concat(srcValue) : undefined;}; // Straight from the lodash docs
"use strict";// Straight from the lodash docsvar mergeAllArrays = _fp.default.mergeAllWith(mergeArrays); // { a: [x, y, z], b: [x] } -> { x: [a, b], y: [a], z: [a] }
"use strict";// { a: [x, y, z], b: [x] } -> { x: [a, b], y: [a], z: [a] }var invertByArray = _fp.default.flow((0, _conversion.mapIndexed)(function (arr, key) {  return (0, _array.zipObjectDeepWith)(arr, function () {    return [key];  });}), mergeAllArrays); // key -> { a: { x: 1 }, b: { y: 2 } } -> { a: { x: 1, key: 'a' }, b: { y: 2, key: 'b' } }
"use strict";function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }// key -> { a: { x: 1 }, b: { y: 2 } } -> { a: { x: 1, key: 'a' }, b: { y: 2, key: 'b' } }var stampKey = _fp.default.curry(function (key, x) {  return (0, _conversion.mapValuesIndexed)(function (val, k) {    return _objectSpread(_objectSpread({}, val), {}, {      [key]: k    });  }, x);});
"use strict";var omitNil = function omitNil(x) {  return _fp.default.omitBy(_fp.default.isNil, x);};
"use strict";var omitNull = function omitNull(x) {  return _fp.default.omitBy(_fp.default.isNull, x);};
"use strict";var omitBlank = function omitBlank(x) {  return _fp.default.omitBy(_lang.isBlank, x);};
"use strict";var omitEmpty = function omitEmpty(x) {  return _fp.default.omitBy(_fp.default.isEmpty, x);}; // ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";// ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAll = _fp.default.curryN(2, function (fns) {  for (var _len = arguments.length, x = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    x[_key - 1] = arguments[_key];  }  return _fp.default.flow(_fp.default.over(fns), _fp.default.mergeAll).apply(void 0, x);}); // customizer -> ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";var _len = arguments.length,    x = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// customizer -> ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAllWith = _fp.default.curryN(3, function (customizer, fns) {  for (var _len2 = arguments.length, x = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {    x[_key2 - 2] = arguments[_key2];  }  return _fp.default.flow(_fp.default.over(fns), _fp.default.mergeAllWith(customizer)).apply(void 0, x);}); // ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";var _len2 = arguments.length,    x = new Array(_len2 > 2 ? _len2 - 2 : 0),    _key2 = 2;
"use strict";// ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAllArrays = mergeOverAllWith(mergeArrays); // (x -> y) -> k -> {k: x} -> y
"use strict";// (x -> y) -> k -> {k: x} -> yvar getWith = _fp.default.curry(function (customizer, path, object) {  return customizer(_fp.default.get(path, object));}); // ({a} -> {b}) -> {a} -> {a, b}
"use strict";function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }// ({a} -> {b}) -> {a} -> {a, b}var expandObject = _fp.default.curry(function (transform, obj) {  return _objectSpread(_objectSpread({}, obj), transform(obj));}); // k -> (a -> {b}) -> {k: a} -> {a, b}
"use strict";// k -> (a -> {b}) -> {k: a} -> {a, b}var expandObjectBy = _fp.default.curry(function (key, fn, obj) {  return expandObject(getWith(fn, key))(obj);});
"use strict";var commonKeys = _fp.default.curryN(2, (0, _function.mapArgs)(_fp.default.keys, _fp.default.intersection));
"use strict";var findKeyIndexed = _fp.default.findKey.convert({  cap: false});
"use strict";var firstCommonKey = _fp.default.curry(function (x, y) {  return findKeyIndexed(function (val, key) {    return _fp.default.has(key, x);  }, y);});
"use strict";var _collection = require("./collection");
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _logic = require("./logic");
"use strict";var _array = require("./array");
"use strict";var _iterators = require("./iterators");
"use strict";var wrap = function wrap(pre, post, content) {  return (pre || '') + content + (post || pre || '');};
"use strict";var quote = _fp.default.partial(wrap, ['"', '"']);
"use strict";var parens = _fp.default.partial(wrap, ['(', ')']);
"use strict";var concatStrings = _fp.default.flow(_fp.default.compact, _fp.default.map(_fp.default.trim), _fp.default.join(' '));
"use strict";var trimStrings = (0, _collection.map)((0, _logic.when)(_fp.default.isString, _fp.default.trim)); // _.startCase does the trick, deprecate it!
"use strict";// _.startCase does the trick, deprecate it!var autoLabel = _fp.default.startCase;
"use strict";var autoLabelOption = function autoLabelOption(a) {  return {    value: (0, _logic.when)(_fp.default.isUndefined, a)(a.value),    label: a.label || autoLabel((0, _logic.when)(_fp.default.isUndefined, a)(a.value))  };};
"use strict";var autoLabelOptions = _fp.default.map(autoLabelOption);
"use strict";var toSentenceWith = _fp.default.curry(function (separator, lastSeparator, array) {  return _fp.default.flow((0, _array.intersperse)((0, _iterators.differentLast)(function () {    return separator;  }, function () {    return lastSeparator;  })), _fp.default.join(''))(array);});
"use strict";var toSentence = toSentenceWith(', ', ' and '); // ((array -> object), array) -> string -> string
"use strict";// ((array -> object), array) -> string -> stringvar uniqueStringWith = _fp.default.curry(function (cachizer, initialKeys) {  var f = function f(x) {    var result = x;    while (cache[result]) {      result = x + cache[x];      cache[x] += 1;    }    cache[result] = (cache[result] || 0) + 1;    return result;  };  var cache = cachizer(initialKeys);  f.cache = cache;  f.clear = function () {    cache = {};    f.cache = cache;  };  return f;});
"use strict";var f = function f(x) {  var result = x;  while (cache[result]) {    result = x + cache[x];    cache[x] += 1;  }  cache[result] = (cache[result] || 0) + 1;  return result;};
"use strict";var result = x;
"use strict";var cache = cachizer(initialKeys);
"use strict";var uniqueString = function uniqueString() {  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];  return uniqueStringWith(_fp.default.countBy(_fp.default.identity), arr);};
"use strict";var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _lang = require("./lang");
"use strict";// Corevar aspect = function aspect(_ref) {  var _ref$name = _ref.name,      name = _ref$name === void 0 ? 'aspect' : _ref$name,      _ref$init = _ref.init,      init = _ref$init === void 0 ? _fp.default.noop : _ref$init,      _ref$after = _ref.after,      after = _ref$after === void 0 ? _fp.default.noop : _ref$after,      _ref$before = _ref.before,      before = _ref$before === void 0 ? _fp.default.noop : _ref$before,      _ref$always = _ref.always,      always = _ref$always === void 0 ? _fp.default.noop : _ref$always,      _ref$onError = _ref.onError,      onError = _ref$onError === void 0 ? _lang.throws : _ref$onError;  return function (f) {    var _f$state = f.state,        state = _f$state === void 0 ? {} : _f$state;    init(state); // Trick to set function.name of anonymous function    var x = {      [name]() {        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {          args[_key] = arguments[_key];        }        var result;        var error;        return Promise.resolve().then(function () {          return before(args, state);        }).then(function () {          return f.apply(void 0, args);        }).then(function (r) {          result = r;        }).then(function () {          return after(result, state, args);        }).catch(function (e) {          return onError(e, state, args);        }).catch(function (e) {          error = e;        }).then(function () {          return always(state, args);        }).then(function () {          if (error) throw error;        }).then(function () {          return result;        });      }    };    x[name].state = state;    return x[name];  };};
"use strict";var _ref2 = _ref,    _ref2$name = _ref2.name,    name = _ref2$name === void 0 ? 'aspect' : _ref2$name,    _ref2$init = _ref2.init,    init = _ref2$init === void 0 ? _fp.default.noop : _ref2$init,    _ref2$after = _ref2.after,    after = _ref2$after === void 0 ? _fp.default.noop : _ref2$after,    _ref2$before = _ref2.before,    before = _ref2$before === void 0 ? _fp.default.noop : _ref2$before,    _ref2$always = _ref2.always,    always = _ref2$always === void 0 ? _fp.default.noop : _ref2$always,    _ref2$onError = _ref2.onError,    onError = _ref2$onError === void 0 ? _lang.throws : _ref2$onError;
"use strict";var _f = f,    _f$state = _f.state,    state = _f$state === void 0 ? {} : _f$state;
"use strict";// Trick to set function.name of anonymous functionvar x = {  [name]() {    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {      args[_key] = arguments[_key];    }    var result;    var error;    return Promise.resolve().then(function () {      return before(args, state);    }).then(function () {      return f.apply(void 0, args);    }).then(function (r) {      result = r;    }).then(function () {      return after(result, state, args);    }).catch(function (e) {      return onError(e, state, args);    }).catch(function (e) {      error = e;    }).then(function () {      return always(state, args);    }).then(function () {      if (error) throw error;    }).then(function () {      return result;    });  }};
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var result;
"use strict";var error;
"use strict";var aspectSync = function aspectSync(_ref2) {  var _ref2$name = _ref2.name,      name = _ref2$name === void 0 ? 'aspect' : _ref2$name,      _ref2$init = _ref2.init,      init = _ref2$init === void 0 ? _fp.default.noop : _ref2$init,      _ref2$after = _ref2.after,      after = _ref2$after === void 0 ? _fp.default.noop : _ref2$after,      _ref2$before = _ref2.before,      before = _ref2$before === void 0 ? _fp.default.noop : _ref2$before,      _ref2$always = _ref2.always,      always = _ref2$always === void 0 ? _fp.default.noop : _ref2$always,      _ref2$onError = _ref2.onError,      onError = _ref2$onError === void 0 ? _lang.throws : _ref2$onError;  return function (f) {    var _f$state = f.state,        state = _f$state === void 0 ? {} : _f$state;    init(state); // Trick to set function.name of anonymous function    var x = {      [name]() {        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {          args[_key2] = arguments[_key2];        }        try {          before(args, state);          var result = f.apply(void 0, args);          after(result, state, args);          return result;        } catch (e) {          onError(e, state, args);          throw e;        } finally {          always(state, args);        }      }    };    x[name].state = state;    return x[name];  };}; // Example Aspects
"use strict";var _ref = _ref2,    _ref$name = _ref.name,    name = _ref$name === void 0 ? 'aspect' : _ref$name,    _ref$init = _ref.init,    init = _ref$init === void 0 ? _fp.default.noop : _ref$init,    _ref$after = _ref.after,    after = _ref$after === void 0 ? _fp.default.noop : _ref$after,    _ref$before = _ref.before,    before = _ref$before === void 0 ? _fp.default.noop : _ref$before,    _ref$always = _ref.always,    always = _ref$always === void 0 ? _fp.default.noop : _ref$always,    _ref$onError = _ref.onError,    onError = _ref$onError === void 0 ? _lang.throws : _ref$onError;
"use strict";var _f = f,    _f$state = _f.state,    state = _f$state === void 0 ? {} : _f$state;
"use strict";// Trick to set function.name of anonymous functionvar x = {  [name]() {    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {      args[_key2] = arguments[_key2];    }    try {      before(args, state);      var result = f.apply(void 0, args);      after(result, state, args);      return result;    } catch (e) {      onError(e, state, args);      throw e;    } finally {      always(state, args);    }  }};
"use strict";var _len2 = arguments.length,    args = new Array(_len2),    _key2 = 0;
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var result = f.apply(void 0, _toConsumableArray(args));
"use strict";// Example Aspectsvar logs = function logs() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      logs: []    }),    after: function after(result, state) {      return state.logs.push(result);    },    name: 'logs'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var error = function error() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      error: null    }),    onError: (0, _conversion.setOn)('error'),    name: 'error'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var errors = function errors() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      errors: []    }),    onError: function onError(e, state) {      return state.errors.push(e);    },    name: 'errors'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var status = function status() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      status: null,      processing: false,      succeeded: false,      failed: false,      // Computed get/set properties don't work, probably because lodash extend methods don't support copying them      setStatus(x) {        this.status = x;        this.failed = x === 'failed';        this.succeeded = x === 'succeeded';        this.processing = x === 'processing';      }    }),    before(params, state) {      state.setStatus('processing');    },    after(result, state) {      state.setStatus('succeeded');    },    onError: (0, _lang.tapError)(function (e, state) {      state.setStatus('failed');    }),    name: 'status'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var clearStatus = function clearStatus() {  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;  return aspect({    always(state) {      if (timeout !== null) {        setTimeout(function () {          state.setStatus(null);        }, timeout);      }    },    name: 'clearStatus'  });}; // This is a function just for consistency
"use strict";var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
"use strict";// This is a function just for consistencyvar concurrency = function concurrency() {  return aspect({    before(params, state) {      if (state.processing) {        throw Error('Concurrent Runs Not Allowed');      }    },    name: 'concurrency'  });};
"use strict";var command = function command(extend, timeout) {  return _fp.default.flow(status(extend), clearStatus(timeout), concurrency(extend), error(extend));};
"use strict";var deprecate = function deprecate(subject, version, alternative) {  return aspectSync({    before: function before() {      return console.warn("`".concat(subject, "` is deprecated").concat(version ? " as of ".concat(version) : '').concat(alternative ? " in favor of `".concat(alternative, "`") : '', " ").concat(_fp.default.trim((Error().stack || '').split('\n')[3])));    }  });};
"use strict";var aspects = {  logs,  error,  errors,  status,  deprecate,  clearStatus,  concurrency,  command};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _aspect = require("./aspect");
"use strict";var noRearg = _fp.default.convert({  rearg: false});
"use strict";var mutable = _fp.default.convert({  immutable: false});
"use strict";var noCap = _fp.default.convert({  cap: false}); // Flips// ----------
"use strict";// Flips// ----------var getIn = noRearg.get;
"use strict";var hasIn = noRearg.has;
"use strict";var pickIn = noRearg.pick;
"use strict";var includesIn = noRearg.includes;
"use strict";var inversions = _fp.default.mapKeys(function (k) {  return "".concat(k, "In");}, noRearg); // Mutables// ----------
"use strict";// Mutables// ----------var extendOn = mutable.extend;
"use strict";var defaultsOn = mutable.defaults;
"use strict";var mergeOn = mutable.merge;
"use strict";var setOn = mutable.set; // Curry required until https://github.com/lodash/lodash/issues/3440 is resolved
"use strict";// Curry required until https://github.com/lodash/lodash/issues/3440 is resolvedvar unsetOn = _fp.default.curryN(2, mutable.unset);
"use strict";var pullOn = mutable.pull;
"use strict";var updateOn = mutable.update; // Uncaps// ------// Un-prefixed Deprecated
"use strict";// Uncaps// ------// Un-prefixed Deprecatedvar reduce = _aspect.aspects.deprecate('reduce', '1.28.0', 'reduceIndexed')(noCap.reduce);
"use strict";var mapValues = _aspect.aspects.deprecate('mapValues', '1.28.0', 'mapValuesIndexed')(noCap.mapValues);
"use strict";var each = _aspect.aspects.deprecate('each', '1.28.0', 'eachIndexed')(noCap.each);
"use strict";var mapIndexed = noCap.map;
"use strict";var findIndexed = noCap.find;
"use strict";var eachIndexed = noCap.each;
"use strict";var reduceIndexed = noCap.reduce;
"use strict";var pickByIndexed = noCap.pickBy;
"use strict";var mapValuesIndexed = noCap.mapValues;
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _tree = require("./tree");
"use strict";var throws = function throws(x) {  throw x;};
"use strict";var tapError = function tapError(f) {  return function (e) {    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {      args[_key - 1] = arguments[_key];    }    f.apply(void 0, [e].concat(args));    throw e;  };};
"use strict";var _len = arguments.length,    args = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";var isNotNil = _fp.default.negate(_fp.default.isNil);
"use strict";var exists = isNotNil;
"use strict";var isMultiple = function isMultiple(x) {  return (x || []).length > 1;};
"use strict";var append = _fp.default.curry(function (x, y) {  return y + x;}); // True for everything except null, undefined, '', [], and {}
"use strict";// True for everything except null, undefined, '', [], and {}var isBlank = _fp.default.overSome([_fp.default.isNil, _fp.default.isEqual(''), _fp.default.isEqual([]), _fp.default.isEqual({})]);
"use strict";var isNotBlank = _fp.default.negate(isBlank);
"use strict";var isBlankDeep = function isBlankDeep(combinator) {  return function (x) {    return combinator(isBlank, (0, _tree.tree)().leaves(x));  };};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _function = require("./function");
"use strict";var _lang = require("./lang");
"use strict";// ([f, g]) -> !f(x) && !g(x)var overNone = _fp.default.flow(_fp.default.overSome, _fp.default.negate);
"use strict";var boolIteratee = function boolIteratee(x) {  return _fp.default.isBoolean(x) || _fp.default.isNil(x) ? function () {    return x;  } : _fp.default.iteratee(x);}; // Port from Ramda
"use strict";// Port from Ramdavar ifElse = _fp.default.curry(function (condition, onTrue, onFalse, x) {  return boolIteratee(condition)(x) ? (0, _function.callOrReturn)(onTrue, x) : (0, _function.callOrReturn)(onFalse, x);});
"use strict";var when = _fp.default.curry(function (condition, t, x) {  return ifElse(condition, t, _fp.default.identity, x);});
"use strict";var unless = _fp.default.curry(function (condition, f, x) {  return ifElse(condition, _fp.default.identity, f, x);});
"use strict";var whenExists = when(_lang.exists);
"use strict";var whenTruthy = when(Boolean);
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _array = require("./array");
"use strict";var _collection = require("./collection");
"use strict";var testRegex = _fp.default.curry(function (regex, str) {  return new RegExp(regex).test(str);});
"use strict";var makeRegex = function makeRegex(options) {  return function (text) {    return RegExp(text, options);  };};
"use strict";var makeAndTest = function makeAndTest(options) {  return _fp.default.flow(makeRegex(options), testRegex);};
"use strict";var anyWordToRegexp = _fp.default.flow(_fp.default.words, _fp.default.join('|'));
"use strict";var wordsToRegexp = _fp.default.flow(_fp.default.words, _fp.default.map(function (x) {  return "(?=.*".concat(x, ".*)");}), _fp.default.join(''), function (x) {  return ".*".concat(x, ".*");});
"use strict";var matchWords = _fp.default.curry(function (buildRegex, x) {  // Not inlining so that we don't create the regexp every time  var regexp = RegExp(buildRegex(x), 'gi');  return function (y) {    return !!(y && y.match(regexp));  };});
"use strict";// Not inlining so that we don't create the regexp every timevar regexp = RegExp(buildRegex(x), 'gi');
"use strict";var matchAllWords = matchWords(wordsToRegexp);
"use strict";var matchAnyWord = matchWords(anyWordToRegexp);
"use strict";var allMatches = _fp.default.curry(function (regexStr, str) {  var matched;  var regex = new RegExp(regexStr, 'g');  var result = [];  while ((matched = regex.exec(str)) !== null) {    result.push({      text: matched[0],      start: matched.index,      end: regex.lastIndex    });  }  return result;});
"use strict";var matched;
"use strict";var regex = new RegExp(regexStr, 'g');
"use strict";var result = [];
"use strict";var postings = _fp.default.curry(function (regex, str) {  var match = regex.exec(str);  var result = [];  if (regex.flags.indexOf('g') < 0 && match) {    result.push([match.index, match.index + match[0].length]);  } else {    while (match) {      result.push([match.index, regex.lastIndex]);      match = regex.exec(str);    }  }  return result;});
"use strict";var match = regex.exec(str);
"use strict";var result = [];
"use strict";var postingsForWords = _fp.default.curry(function (string, str) {  return _fp.default.reduce(function (result, word) {    return (0, _array.push)(postings(RegExp(word, 'gi'), str), result);  }, [])(_fp.default.words(string));});
"use strict";var highlightFromPostings = _fp.default.curry(function (start, end, postings, str) {  var offset = 0;  _fp.default.each(function (posting) {    str = (0, _collection.insertAtIndex)(posting[0] + offset, start, str);    offset += start.length;    str = (0, _collection.insertAtIndex)(posting[1] + offset, end, str);    offset += end.length;  }, (0, _array.mergeRanges)(postings));  return str;});
"use strict";var offset = 0;
"use strict";var highlight = _fp.default.curry(function (start, end, pattern, input) {  return highlightFromPostings(start, end, _fp.default.isRegExp(pattern) ? postings(pattern, input) : _fp.default.flatten(postingsForWords(pattern, input)), input);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _array = require("./array");
"use strict";var isTraversable = function isTraversable(x) {  return _fp.default.isArray(x) || _fp.default.isPlainObject(x);};
"use strict";var traverse = function traverse(x) {  return isTraversable(x) && !_fp.default.isEmpty(x) && x;};
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var walk = function walk() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (pre) {    var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;    var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];    var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];    return function (tree, index) {      return pre(tree, index, parents, parentIndexes) || (0, _conversion.findIndexed)(walk(next)(pre, post, [tree].concat(_toConsumableArray(parents)), [index].concat(_toConsumableArray(parentIndexes))), next(tree, index, parents, parentIndexes) || []) || post(tree, index, parents, parentIndexes);    };  };}; // async/await is so much cleaner but causes regeneratorRuntime shenanigans// export let findIndexedAsync = async (f, data) => {//   for (let key in data) {//     if (await f(data[key], key, data)) return data[key]//   }// }// The general idea here is to keep popping off key/value pairs until we hit something that matches
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;
"use strict";var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
"use strict";var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }// async/await is so much cleaner but causes regeneratorRuntime shenanigans// export let findIndexedAsync = async (f, data) => {//   for (let key in data) {//     if (await f(data[key], key, data)) return data[key]//   }// }// The general idea here is to keep popping off key/value pairs until we hit something that matchesvar findIndexedAsync = function findIndexedAsync(f, data) {  var remaining = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _fp.default.toPairs(data);  if (!remaining.length) return;  var _remaining = _toArray(remaining),      _remaining$ = _slicedToArray(_remaining[0], 2),      key = _remaining$[0],      val = _remaining$[1],      rest = _remaining.slice(1);  return Promise.resolve(f(val, key, data)).then(function (result) {    return result ? val : rest.length ? findIndexedAsync(f, data, rest) : undefined;  });};
"use strict";var remaining = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _fp.default.toPairs(data);
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _remaining = remaining,    _remaining2 = _toArray(_remaining),    _remaining2$ = _slicedToArray(_remaining2[0], 2),    key = _remaining2$[0],    val = _remaining2$[1],    rest = _remaining2.slice(1);
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var walkAsync = function walkAsync() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (pre) {    var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;    var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];    var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];    return function (tree, index) {      return Promise.resolve(pre(tree, index, parents, parentIndexes)).then(function (preResult) {        return preResult || findIndexedAsync(walkAsync(next)(pre, post, [tree].concat(_toConsumableArray(parents)), [index].concat(_toConsumableArray(parentIndexes))), next(tree, index, parents, parentIndexes) || []);      }).then(function (stepResult) {        return stepResult || post(tree, index, parents, parentIndexes);      });    };  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;
"use strict";var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
"use strict";var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
"use strict";var transformTree = function transformTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (f, x) {    var result = _fp.default.cloneDeep(x);    walk(next)(f)(result);    return result;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var result = _fp.default.cloneDeep(x);
"use strict";var reduceTree = function reduceTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (f, result, tree) {    walk(next)(function () {      for (var _len = arguments.length, x = new Array(_len), _key = 0; _key < _len; _key++) {        x[_key] = arguments[_key];      }      result = f.apply(void 0, [result].concat(x));    })(tree);    return result;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len = arguments.length,    x = new Array(_len),    _key = 0;
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var writeProperty = function writeProperty() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (node, index, _ref) {    var _ref2 = _slicedToArray(_ref, 1),        parent = _ref2[0];    next(parent)[index] = node;  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _slicedToArray(_ref2, 1),    parent = _ref3[0];
"use strict";var mapTree = function mapTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);  return _fp.default.curry(function (mapper, tree) {    return transformTree(next)(function (node, i, parents) {      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {        args[_key2 - 3] = arguments[_key2];      }      if (parents.length) writeNode.apply(void 0, [mapper.apply(void 0, [node, i, parents].concat(args)), i, parents].concat(args));    })(mapper(tree));  } // run mapper on root, and skip root in traversal  );};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);
"use strict";var _len2 = arguments.length,    args = new Array(_len2 > 3 ? _len2 - 3 : 0),    _key2 = 3;
"use strict";var mapTreeLeaves = function mapTreeLeaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);  return _fp.default.curry(function (mapper, tree) {    return (// this unless wrapping can be done in user land, this is pure convenience      // mapTree(next, writeNode)(F.unless(next, mapper), tree)      mapTree(next, writeNode)(function (node) {        return next(node) ? node : mapper(node);      }, tree)    );  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);
"use strict";var treeToArrayBy = function treeToArrayBy() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (fn, tree) {    return reduceTree(next)(function (r) {      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {        args[_key3 - 1] = arguments[_key3];      }      return (0, _array.push)(fn.apply(void 0, args), r);    }, [], tree);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len3 = arguments.length,    args = new Array(_len3 > 1 ? _len3 - 1 : 0),    _key3 = 1;
"use strict";var treeToArray = function treeToArray() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return treeToArrayBy(next)(function (x) {    return x;  });}; // This could reuse treeToArrayBy and just reject traversable elements after, but this is more efficient// We can potentially unify these with tree transducers
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";// This could reuse treeToArrayBy and just reject traversable elements after, but this is more efficient// We can potentially unify these with tree transducersvar leavesBy = function leavesBy() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (fn, tree) {    return reduceTree(next)(function (r, node) {      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {        args[_key4 - 2] = arguments[_key4];      }      return next(node) ? r : (0, _array.push)(fn.apply(void 0, [node].concat(args)), r);    }, [], tree);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len4 = arguments.length,    args = new Array(_len4 > 2 ? _len4 - 2 : 0),    _key4 = 2;
"use strict";var leaves = function leaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return leavesBy(next)(function (x) {    return x;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var treeLookup = function treeLookup() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;  return _fp.default.curry(function (path, tree) {    return _fp.default.reduce(function (tree, path) {      return (0, _conversion.findIndexed)(buildIteratee(path), next(tree));    }, tree, path);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;
"use strict";var keyTreeByWith = function keyTreeByWith() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (transformer, groupIteratee, x) {    return _fp.default.flow(treeToArrayBy(next)(_fp.default.iteratee(groupIteratee)), _fp.default.uniq, _fp.default.keyBy(_fp.default.identity), _fp.default.mapValues(function (group) {      return transformTree(next)(function (node) {        var matches = _fp.default.iteratee(groupIteratee)(node) === group;        transformer(node, matches, group);      }, x);    }))(x);  });}; // Flat Tree
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var matches = _fp.default.iteratee(groupIteratee)(node) === group;
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }// Flat Treevar treeKeys = function treeKeys(x, i, xs, is) {  return [i].concat(_toConsumableArray(is));};
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var treeValues = function treeValues(x, i, xs) {  return [x].concat(_toConsumableArray(xs));};
"use strict";var treePath = function treePath() {  var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treeKeys;  var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _array.dotEncoder;  return function () {    return (encoder.encode || encoder)(build.apply(void 0, arguments).reverse());  };};
"use strict";var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treeKeys;
"use strict";var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _array.dotEncoder;
"use strict";var propTreePath = function propTreePath(prop) {  return treePath(_fp.default.flow(treeValues, _fp.default.map(prop)), _array.slashEncoder);};
"use strict";var flattenTree = function flattenTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function () {    var buildPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treePath();    return reduceTree(next)(function (result, node) {      for (var _len5 = arguments.length, x = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {        x[_key5 - 2] = arguments[_key5];      }      return _fp.default.set([buildPath.apply(void 0, [node].concat(x))], node, result);    }, {});  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treePath();
"use strict";var _len5 = arguments.length,    x = new Array(_len5 > 2 ? _len5 - 2 : 0),    _key5 = 2;
"use strict";var flatLeaves = function flatLeaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.reject(next);};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var tree = function tree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;  var writeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : writeProperty(next);  return {    walk: walk(next),    walkAsync: walkAsync(next),    transform: transformTree(next),    reduce: reduceTree(next),    toArrayBy: treeToArrayBy(next),    toArray: treeToArray(next),    leaves: leaves(next),    leavesBy: leavesBy(next),    lookup: treeLookup(next, buildIteratee),    keyByWith: keyTreeByWith(next),    traverse: next,    flatten: flattenTree(next),    flatLeaves: flatLeaves(next),    map: mapTree(next, writeNode),    mapLeaves: mapTreeLeaves(next, writeNode)  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;
"use strict";var writeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : writeProperty(next);
