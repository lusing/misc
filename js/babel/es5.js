"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _function = require("./function");
"use strict";var _collection = require("./collection");
"use strict";var _conversion = require("./conversion");
"use strict";// TODO: Move to proper files and exposevar callUnless = function callUnless(check) {  return function (failFn) {    return function (fn) {      return function (x, y) {        return check(x) ? failFn(y) : check(y) ? failFn(x) : fn(x, y);      };    };  };};
"use strict";var callUnlessEmpty = callUnless(_fp.default.isEmpty);
"use strict";var wrapArray = function wrapArray(x) {  return [x];};
"use strict";var callUnlessEmptyArray = callUnlessEmpty(wrapArray);
"use strict";var dropRight = _fp.default.dropRight(1);
"use strict";var last = _fp.default.takeRight(1); // Arrays// ------
"use strict";// Arrays// ------var compactJoin = _fp.default.curry(function (join, x) {  return _fp.default.compact(x).join(join);});
"use strict";var dotJoin = compactJoin('.');
"use strict";var dotJoinWith = function dotJoinWith(fn) {  return function (x) {    return _fp.default.filter(fn, x).join('.');  };};
"use strict";var repeated = _fp.default.flow(_fp.default.groupBy(function (e) {  return e;}), _fp.default.filter(function (e) {  return e.length > 1;}), _fp.default.flatten, _fp.default.uniq);
"use strict";var push = _fp.default.curry(function (val, arr) {  return arr.concat([val]);});
"use strict";var pushIn = _fp.default.curry(function (arr, val) {  return arr.concat([val]);});
"use strict";var pushOn = _fp.default.curry(function (arr, val) {  arr.push(val);  return arr;});
"use strict";var moveIndex = function moveIndex(from, to, arr) {  return _fp.default.flow(_fp.default.pullAt(from), (0, _collection.insertAtIndex)(to, arr[from]))(arr);};
"use strict";var overlaps = function overlaps(x, y) {  return y[0] > x[1];};
"use strict";var mergeRange = function mergeRange(x, y) {  return [[x[0], _fp.default.max(x.concat(y))]];};
"use strict";var actuallMergeRanges = callUnlessEmptyArray(function (x, y) {  return overlaps(x, y) ? [x, y] : mergeRange(x, y);});
"use strict";var mergeRanges = _fp.default.flow(_fp.default.sortBy([0, 1]), _fp.default.reduce(function (result, range) {  return dropRight(result).concat(actuallMergeRanges(_fp.default.flatten(last(result)), range));}, [])); // [a, b...] -> a -> b
"use strict";// [a, b...] -> a -> bvar cycle = _fp.default.curry(function (a, n) {  return a[(a.indexOf(n) + 1) % a.length];});
"use strict";var arrayToObject = _fp.default.curry(function (k, v, a) {  return _fp.default.flow(_fp.default.keyBy(k), _fp.default.mapValues(v))(a);}); // zipObject that supports functions instead of objects
"use strict";// zipObject that supports functions instead of objectsvar zipObjectDeepWith = _fp.default.curry(function (x, y) {  return _fp.default.zipObjectDeep(x, _fp.default.isFunction(y) && _fp.default.isArray(x) ? _fp.default.times(y, x.length) : y);});
"use strict";var flags = zipObjectDeepWith(_fp.default, function () {  return true;});
"use strict";var prefixes = function prefixes(list) {  return _fp.default.range(1, list.length + 1).map(function (x) {    return _fp.default.take(x, list);  });};
"use strict";var encoder = function encoder(separator) {  return {    encode: compactJoin(separator),    decode: _fp.default.split(separator)  };};
"use strict";var dotEncoder = encoder('.');
"use strict";var slashEncoder = encoder('/');
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var chunkBy = _fp.default.curry(function (f, array) {  return _fp.default.isEmpty(array) ? [] : _fp.default.reduce(function (acc, x) {    return f(_fp.default.last(acc), x) ? [].concat(_toConsumableArray(_fp.default.initial(acc)), [[].concat(_toConsumableArray(_fp.default.last(acc)), [x])]) : [].concat(_toConsumableArray(acc), [[x]]);  }, [[_fp.default.head(array)]], _fp.default.tail(array));});
"use strict";var toggleElementBy = _fp.default.curry(function (check, val, arr) {  return ((0, _function.callOrReturn)(check, val, arr) ? _fp.default.pull : push)(val, arr);});
"use strict";var toggleElement = toggleElementBy(_fp.default.includes);
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var intersperse = _fp.default.curry(function (f, _ref) {  var _ref2 = _toArray(_ref),      x0 = _ref2[0],      xs = _ref2.slice(1);  return (0, _conversion.reduceIndexed)(function (acc, x, i) {    return i === xs.length ? [].concat(_toConsumableArray(acc), [x]) : [].concat(_toConsumableArray(acc), [(0, _function.callOrReturn)(f, acc, i, xs), x]);  }, [x0], xs);});
"use strict";function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _toArray(_ref2),    x0 = _ref3[0],    xs = _ref3.slice(1);
"use strict";var replaceElementBy = _fp.default.curry(function (f, b, arr) {  return _fp.default.map(function (c) {    return f(c) ? b : c;  }, arr);});
"use strict";var replaceElement = _fp.default.curry(function (a, b, arr) {  return replaceElementBy(_fp.default.isEqual(a), b, arr);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _tree = require("./tree");
"use strict";var flowMap = function flowMap() {  var _fp$default;  return _fp.default.map((_fp$default = _fp.default).flow.apply(_fp$default, arguments));};
"use strict";var findApply = _fp.default.curry(function (f, arr) {  return _fp.default.iteratee(f)(_fp.default.find(f, arr));}); // Algebras// --------// A generic map that works for plain objects and arrays
"use strict";// Algebras// --------// A generic map that works for plain objects and arraysvar map = _fp.default.curry(function (f, x) {  return (_fp.default.isArray(x) ? _fp.default.map : _fp.default.mapValues).convert({    cap: false  })(f, x);}); // Map for any recursive algebraic data structure// defaults in multidimensional arrays and recursive plain objects
"use strict";// Map for any recursive algebraic data structure// defaults in multidimensional arrays and recursive plain objectsvar deepMap = _fp.default.curry(function (fn, obj) {  var _map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : map;  var is = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tree.isTraversable;  return _map(function (e) {    return is(e) ? deepMap(fn, fn(e), _map, is) : e;  }, obj);});
"use strict";var _map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : map;
"use strict";var is = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tree.isTraversable;
"use strict";var insertAtStringIndex = function insertAtStringIndex(index, val, str) {  return str.slice(0, index) + val + str.slice(index);};
"use strict";var insertAtArrayIndex = function insertAtArrayIndex(index, val, arr) {  var result = _fp.default.clone(arr);  result.splice(index, 0, val);  return result;};
"use strict";var result = _fp.default.clone(arr);
"use strict";var insertAtIndex = _fp.default.curry(function (index, val, collection) {  return _fp.default.isString(collection) ? insertAtStringIndex(index, val, collection) : insertAtArrayIndex(index, val, collection);});
"use strict";var compactMap = _fp.default.curry(function (fn, collection) {  return _fp.default.flow(_fp.default.map(fn), _fp.default.compact)(collection);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";// (fn, a, b) -> fn(a, b)var maybeCall = function maybeCall(fn) {  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    args[_key - 1] = arguments[_key];  }  return _fp.default.isFunction(fn) && fn.apply(void 0, args);}; // (fn, a, b) -> fn(a, b)
"use strict";var _len = arguments.length,    args = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// (fn, a, b) -> fn(a, b)var callOrReturn = function callOrReturn(fn) {  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {    args[_key2 - 1] = arguments[_key2];  }  return _fp.default.isFunction(fn) ? fn.apply(void 0, args) : fn;}; // (a, Monoid f) -> f[a] :: f a
"use strict";var _len2 = arguments.length,    args = new Array(_len2 > 1 ? _len2 - 1 : 0),    _key2 = 1;
"use strict";// (a, Monoid f) -> f[a] :: f avar boundMethod = function boundMethod(method, object) {  return object[method].bind(object);}; // http://ramdajs.com/docs/#converge
"use strict";// http://ramdajs.com/docs/#convergevar converge = function converge(converger, branches) {  return function () {    return converger(_fp.default.over(branches).apply(void 0, arguments));  };};
"use strict";var composeApply = function composeApply(f, g) {  return function (x) {    return f(g(x))(x);  };};
"use strict";var comply = composeApply; // Prettier version of `defer` the one from bluebird docs
"use strict";// Prettier version of `defer` the one from bluebird docsvar defer = function defer() {  var resolve;  var reject;  var promise = new Promise(function (res, rej) {    resolve = res;    reject = rej;  });  return {    resolve,    reject,    promise  };}; // `_.debounce` for async functions, which require consistently returning a single promise for all queued calls
"use strict";var resolve;
"use strict";var reject;
"use strict";var promise = new Promise(function (res, rej) {  resolve = res;  reject = rej;});
"use strict";// `_.debounce` for async functions, which require consistently returning a single promise for all queued callsvar debounceAsync = function debounceAsync(n, f) {  var deferred = defer();  var debounced = _fp.default.debounce(n, function () {    deferred.resolve(f.apply(void 0, arguments));    deferred = defer();  });  return function () {    debounced.apply(void 0, arguments);    return deferred.promise;  };};
"use strict";var deferred = defer();
"use strict";var debounced = _fp.default.debounce(n, function () {  deferred.resolve(f.apply(void 0, arguments));  deferred = defer();});
"use strict";var currier = function currier(f) {  return function () {    for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {      fns[_key3] = arguments[_key3];    }    return _fp.default.curryN(fns[0].length, f.apply(void 0, fns));  };}; // (f1, f2, ...fn) -> f1Args1 -> f1Arg2 -> ...f1ArgN -> fn(f2(f1))
"use strict";var _len3 = arguments.length,    fns = new Array(_len3),    _key3 = 0;
"use strict";// (f1, f2, ...fn) -> f1Args1 -> f1Arg2 -> ...f1ArgN -> fn(f2(f1))var flurry = currier(_fp.default.flow); // like _.overArgs, but on all args
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }// like _.overArgs, but on all argsvar mapArgs = _fp.default.curry(function (mapper, fn) {  return function () {    for (var _len4 = arguments.length, x = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {      x[_key4] = arguments[_key4];    }    return fn.apply(void 0, _toConsumableArray(x.map(mapper)));  };});
"use strict";var _len4 = arguments.length,    x = new Array(_len4),    _key4 = 0;
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var differentLast = function differentLast(normalCase, lastCase) {  return function (acc, i, list) {    return i === list.length - 1 ? _fp.default.iteratee(lastCase)(acc, i, list) : _fp.default.iteratee(normalCase)(acc, i, list);  };};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _array = require("./array");
"use strict";var _logic = require("./logic");
"use strict";// Stubsvar functionLens = function functionLens(val) {  return function () {    if (!arguments.length) return val;    val = arguments.length <= 0 ? undefined : arguments[0];  };};
"use strict";var objectLens = function objectLens(val) {  return {    get: function get() {      return val;    },    set(x) {      val = x;    }  };}; // Lens Conversion
"use strict";// Lens Conversionvar fnToObj = function fnToObj(fn) {  return {    get: fn,    set: fn  };};
"use strict";var objToFn = function objToFn(lens) {  return function () {    return arguments.length ? lens.set(arguments.length <= 0 ? undefined : arguments[0]) : lens.get();  };}; // Lens Construction
"use strict";// Lens Constructionvar lensProp = function lensProp(field, source) {  return {    get: function get() {      return _fp.default.get(field, source);    },    //source[field],    set(value) {      (0, _conversion.setOn)(field, value, source); // source[field] = value    }  };}; // NOTE: This used to use mapValues; however, doing so would sometimes cause issues// in some edge cases like trying to lens state coming from an inject function// in the mobx library. It would inadvertently cause the inject to re-run.// Using reduce here alleviates that issue.
"use strict";// NOTE: This used to use mapValues; however, doing so would sometimes cause issues// in some edge cases like trying to lens state coming from an inject function// in the mobx library. It would inadvertently cause the inject to re-run.// Using reduce here alleviates that issue.var lensOf = function lensOf(object) {  return _fp.default.reduce(function (res, key) {    res[key] = lensProp(key, object);    return res;  }, {}, _fp.default.keys(object));};
"use strict";var includeLens = function includeLens(value) {  for (var _len = arguments.length, lens = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    lens[_key - 1] = arguments[_key];  }  return {    get: function get() {      return _fp.default.includes(value, view.apply(void 0, lens));    },    // Uniq is to ensure multiple calls to set(true) don't push multiple times since this is about membership of a set    set: function (_set) {      function set(_x) {        return _set.apply(this, arguments);      }      set.toString = function () {        return _set.toString();      };      return set;    }(function (x) {      return set.apply(void 0, [_fp.default.uniq((0, _array.toggleElementBy)(!x, value, view.apply(void 0, lens)))].concat(lens));    })  };}; // Lens Manipulation//let construct = (...lens) => (lens[1] ? lensProp(...lens) : lens[0])
"use strict";var _len = arguments.length,    lens = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// Lens Manipulation//let construct = (...lens) => (lens[1] ? lensProp(...lens) : lens[0])var lensPair = function lensPair(get, set) {  return {    get,    set  };};
"use strict";var construct = function construct() {  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {    args[_key2] = arguments[_key2];  }  return args[1] ? _fp.default.every(_fp.default.isFunction, args) ? lensPair.apply(void 0, args) : lensProp.apply(void 0, args) : (0, _logic.when)(_fp.default.isArray, stateLens)(args[0]);};
"use strict";var _len2 = arguments.length,    args = new Array(_len2),    _key2 = 0;
"use strict";var read = function read(lens) {  return lens.get ? lens.get() : lens();};
"use strict";var view = function view() {  return read(construct.apply(void 0, arguments));};
"use strict";var views = function views() {  for (var _len3 = arguments.length, lens = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {    lens[_key3] = arguments[_key3];  }  return function () {    return view.apply(void 0, lens);  };};
"use strict";var _len3 = arguments.length,    lens = new Array(_len3),    _key3 = 0;
"use strict";var write = function write(val, lens) {  return lens.set ? lens.set(val) : lens(val);};
"use strict";var set = _fp.default.curryN(2, function (val) {  for (var _len4 = arguments.length, lens = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {    lens[_key4 - 1] = arguments[_key4];  }  return write(val, construct.apply(void 0, lens));});
"use strict";var _len4 = arguments.length,    lens = new Array(_len4 > 1 ? _len4 - 1 : 0),    _key4 = 1;
"use strict";var sets = _fp.default.curryN(2, function (val) {  for (var _len5 = arguments.length, lens = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {    lens[_key5 - 1] = arguments[_key5];  }  return function () {    return set.apply(void 0, [val].concat(lens));  };});
"use strict";var _len5 = arguments.length,    lens = new Array(_len5 > 1 ? _len5 - 1 : 0),    _key5 = 1;
"use strict";var setsWith = _fp.default.curry(function (f) {  for (var _len6 = arguments.length, lens = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {    lens[_key6 - 1] = arguments[_key6];  }  return function (x) {    return set.apply(void 0, [_fp.default.iteratee(f)(x)].concat(lens));  };});
"use strict";var _len6 = arguments.length,    lens = new Array(_len6 > 1 ? _len6 - 1 : 0),    _key6 = 1;
"use strict";var flip = function flip() {  for (var _len7 = arguments.length, lens = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {    lens[_key7] = arguments[_key7];  }  return function () {    return set.apply(void 0, [!view.apply(void 0, lens)].concat(lens));  };};
"use strict";var _len7 = arguments.length,    lens = new Array(_len7),    _key7 = 0;
"use strict";var on = sets(true);
"use strict";var off = sets(false); // Lens Consumption// Map lens to dom event handlers
"use strict";// Lens Consumption// Map lens to dom event handlersvar binding = function binding(value, getEventValue) {  return function () {    for (var _len8 = arguments.length, lens = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {      lens[_key8] = arguments[_key8];    }    return {      [value]: view.apply(void 0, lens),      onChange: setsWith.apply(void 0, [getEventValue].concat(lens))    };  };}; // Dom events have relevent fields on the `target` property of event objects
"use strict";var _len8 = arguments.length,    lens = new Array(_len8),    _key8 = 0;
"use strict";// Dom events have relevent fields on the `target` property of event objectsvar targetBinding = function targetBinding(field) {  return binding(field, (0, _logic.when)(_fp.default.hasIn("target.".concat(field)), _fp.default.get("target.".concat(field))));};
"use strict";var domLens = {  value: targetBinding('value'),  checkboxValues: _fp.default.flow(includeLens, targetBinding('checked')),  hover: function hover() {    return {      onMouseEnter: on.apply(void 0, arguments),      onMouseLeave: off.apply(void 0, arguments)    };  },  focus: function focus() {    return {      onFocus: on.apply(void 0, arguments),      onBlur: off.apply(void 0, arguments)    };  },  targetBinding,  binding};
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var stateLens = function stateLens(_ref) {  var _ref2 = _slicedToArray(_ref, 2),      value = _ref2[0],      set = _ref2[1];  return {    get: function get() {      return value;    },    set  };};
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _slicedToArray(_ref2, 2),    value = _ref3[0],    set = _ref3[1];
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _array = require("./array");
"use strict";var _logic = require("./logic");
"use strict";var _lang = require("./lang");
"use strict";var _conversion = require("./conversion");
"use strict";var _collection = require("./collection");
"use strict";var _aspect = require("./aspect");
"use strict";var _function = require("./function");
"use strict";var noCap = _fp.default.convert({  cap: false}); // (k, v) -> {k: v}
"use strict";// (k, v) -> {k: v}var singleObject = _fp.default.curry(function (key, value) {  return {    [key]: value  };});
"use strict";var singleObjectR = _fp.default.flip(singleObject); // Formerly objToObjArr// ({a, b}) -> [{a}, {b}]
"use strict";// Formerly objToObjArr// ({a, b}) -> [{a}, {b}]var chunkObject = function chunkObject(value) {  return _fp.default.isArray(value) ? value : _fp.default.map(_fp.default.spread(singleObject), _fp.default.toPairs(value));}; // Remove properties with falsey values: ({ a: 1, b: null, c: false}) -> {a:1}
"use strict";// Remove properties with falsey values: ({ a: 1, b: null, c: false}) -> {a:1}var compactObject = _fp.default.pickBy(_fp.default.identity);
"use strict";var isEmptyObject = _fp.default.isEqual({});
"use strict";var isNotEmptyObject = _fp.default.negate(isEmptyObject); // { a:1, b:{}, c:2 } -> { a:1, c:2 }
"use strict";// { a:1, b:{}, c:2 } -> { a:1, c:2 }var stripEmptyObjects = _fp.default.pickBy(isNotEmptyObject); // const crazyBS = (f, g) => (a, b) => f(a)(g(b))// { a: { b: 1, c: 2 } }, [ 'b' ] -> { a: { b: 1 } }
"use strict";// const crazyBS = (f, g) => (a, b) => f(a)(g(b))// { a: { b: 1, c: 2 } }, [ 'b' ] -> { a: { b: 1 } }var pickInto = function pickInto(map, source) {  return _fp.default.mapValues((0, _conversion.pickIn)(source), map);};
"use strict";var renameProperty = _fp.default.curry(function (from, to, target) {  return _fp.default.has(from, target) ? _fp.default.flow(function (x) {    return _fp.default.set(to, _fp.default.get(from, x), x);  }, _fp.default.unset(from))(target) : target;}); // { x:['a','b'], y:1 } -> [{ x:'a', y:1 }, { x:'b', y:1 }] just like mongo's `$unwind`
"use strict";// { x:['a','b'], y:1 } -> [{ x:'a', y:1 }, { x:'b', y:1 }] just like mongo's `$unwind`var unwind = _fp.default.curry(function (prop, x) {  return (0, _logic.ifElse)(_fp.default.isArray, _fp.default.map(function (y) {    return _fp.default.set(prop, y, x);  }), _fp.default.stubArray, _fp.default.get(prop, x));}); // this one's _actually_ just like mongo's `$unwind`
"use strict";// this one's _actually_ just like mongo's `$unwind`var unwindArray = _fp.default.curry(function (prop, xs) {  return _fp.default.flatMap(unwind(prop))(xs);});
"use strict";var isFlatObject = (0, _logic.overNone)([_fp.default.isPlainObject, _fp.default.isArray]); // { a: { b: { c: 1 } } } => { 'a.b.c' : 1 }
"use strict";// { a: { b: { c: 1 } } } => { 'a.b.c' : 1 }var flattenObject = function flattenObject(input, paths) {  return (0, _conversion.reduceIndexed)(function (output, value, key) {    return _fp.default.merge(output, (isFlatObject(value) ? singleObjectR : flattenObject)(value, (0, _array.dotJoinWith)(_lang.isNotNil)([paths, key])));  }, {}, input);}; // { 'a.b.c' : 1 } => { a: { b: { c: 1 } } }
"use strict";// { 'a.b.c' : 1 } => { a: { b: { c: 1 } } }var unflattenObject = function unflattenObject(x) {  return _fp.default.zipObjectDeep(_fp.default.keys(x), _fp.default.values(x));}; // Returns true if object keys are only elements from signature list (but does not require all signature keys to be present)
"use strict";// Returns true if object keys are only elements from signature list (but does not require all signature keys to be present)var matchesSignature = _fp.default.curry(function (signature, value) {  return _fp.default.isObject(value) && !_fp.default.difference(_fp.default.keys(value), signature).length;}); // `_.matches` that returns true if one or more of the conditions match instead of all
"use strict";// `_.matches` that returns true if one or more of the conditions match instead of allvar matchesSome = _fp.default.flow(chunkObject, _fp.default.map(_fp.default.matches), _fp.default.overSome); // Checks if a property deep in a given item equals to a given value
"use strict";// Checks if a property deep in a given item equals to a given valuevar compareDeep = _fp.default.curry(function (path, item, value) {  return _fp.default.get(path, item) === value;}); //Depreacted in favor of _.update version from lodash
"use strict";//Depreacted in favor of _.update version from lodashvar mapProp = _aspect.aspects.deprecate('mapProp', '1.46.0', '_.update')(noCap.update); // `_.get` that returns the target object if lookup fails
"use strict";// `_.get` that returns the target object if lookup failsvar getOrReturn = _fp.default.curry(function (prop, x) {  return _fp.default.getOr(x, prop, x);}); // `_.get` that returns the prop if lookup fails
"use strict";// `_.get` that returns the prop if lookup failsvar alias = _fp.default.curry(function (prop, x) {  return _fp.default.getOr(prop, prop, x);}); // flipped alias
"use strict";// flipped aliasvar aliasIn = _fp.default.curry(function (x, prop) {  return _fp.default.getOr(prop, prop, x);}); // A `_.get` that takes an array of paths and returns the value at the first path that matches
"use strict";// A `_.get` that takes an array of paths and returns the value at the first path that matchesvar cascade = _fp.default.curryN(2, function (paths, obj, defaultValue) {  return _fp.default.flow((0, _collection.findApply)(function (x) {    return x && _fp.default.iteratee(x)(obj);  }), _fp.default.defaultTo(defaultValue))(paths);}); // Flipped cascade
"use strict";// Flipped cascadevar cascadeIn = _fp.default.curryN(2, function (obj, paths, defaultValue) {  return cascade(paths, obj, defaultValue);}); // A `_.get` that takes an array of paths and returns the first path that matched
"use strict";// A `_.get` that takes an array of paths and returns the first path that matchedvar cascadeKey = _fp.default.curry(function (paths, obj) {  return _fp.default.find((0, _conversion.getIn)(obj), paths);}); // A `_.get` that takes an array of paths and returns the first path that exists
"use strict";// A `_.get` that takes an array of paths and returns the first path that existsvar cascadePropKey = _fp.default.curry(function (paths, obj) {  return _fp.default.find((0, _conversion.hasIn)(obj), paths);}); // A `_.get` that takes an array of paths and returns the first value that has an existing path
"use strict";// A `_.get` that takes an array of paths and returns the first value that has an existing pathvar cascadeProp = _fp.default.curry(function (paths, obj) {  return _fp.default.get(cascadePropKey(paths, obj), obj);});
"use strict";var unkeyBy = _fp.default.curry(function (keyName, obj) {  return (0, _conversion.mapIndexed)(function (val, key) {    return _fp.default.extend(val, {      [keyName || key]: key    });  })(obj);});
"use strict";var simpleDiff = function simpleDiff(original, deltas) {  var o = flattenObject(original);  return _fp.default.flow(flattenObject, (0, _conversion.mapValuesIndexed)(function (to, field) {    return {      from: o[field],      to    };  }), _fp.default.omitBy(function (x) {    return _fp.default.isEqual(x.from, x.to);  }))(deltas);};
"use strict";var o = flattenObject(original);
"use strict";var simpleDiffArray = _fp.default.flow(simpleDiff, unkeyBy('field'));
"use strict";var diff = function diff(original, deltas) {  var o = flattenObject(original);  var d = flattenObject(deltas);  return _fp.default.flow((0, _conversion.mapValuesIndexed)(function (_, field) {    return {      from: o[field],      to: d[field]    };  }), _fp.default.omitBy(function (x) {    return _fp.default.isEqual(x.from, x.to);  }))(_fp.default.merge(o, d));};
"use strict";var o = flattenObject(original);
"use strict";var d = flattenObject(deltas);
"use strict";var diffArray = _fp.default.flow(diff, unkeyBy('field')); // A `_.pick` that mutates the object
"use strict";// A `_.pick` that mutates the objectvar pickOn = function pickOn() {  var paths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];  var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};  return _fp.default.flow(_fp.default.keys, _fp.default.map(function (key) {    if (!_fp.default.includes(key, paths)) {      delete obj[key];    }  }))(obj);};
"use strict";var paths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
"use strict";var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
"use strict";var mergeArrays = function mergeArrays(objValue, srcValue) {  return _fp.default.isArray(objValue) ? objValue.concat(srcValue) : undefined;}; // Straight from the lodash docs
"use strict";// Straight from the lodash docsvar mergeAllArrays = _fp.default.mergeAllWith(mergeArrays); // { a: [x, y, z], b: [x] } -> { x: [a, b], y: [a], z: [a] }
"use strict";// { a: [x, y, z], b: [x] } -> { x: [a, b], y: [a], z: [a] }var invertByArray = _fp.default.flow((0, _conversion.mapIndexed)(function (arr, key) {  return (0, _array.zipObjectDeepWith)(arr, function () {    return [key];  });}), mergeAllArrays); // key -> { a: { x: 1 }, b: { y: 2 } } -> { a: { x: 1, key: 'a' }, b: { y: 2, key: 'b' } }
"use strict";function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }// key -> { a: { x: 1 }, b: { y: 2 } } -> { a: { x: 1, key: 'a' }, b: { y: 2, key: 'b' } }var stampKey = _fp.default.curry(function (key, x) {  return (0, _conversion.mapValuesIndexed)(function (val, k) {    return _objectSpread(_objectSpread({}, val), {}, {      [key]: k    });  }, x);});
"use strict";var omitNil = function omitNil(x) {  return _fp.default.omitBy(_fp.default.isNil, x);};
"use strict";var omitNull = function omitNull(x) {  return _fp.default.omitBy(_fp.default.isNull, x);};
"use strict";var omitBlank = function omitBlank(x) {  return _fp.default.omitBy(_lang.isBlank, x);};
"use strict";var omitEmpty = function omitEmpty(x) {  return _fp.default.omitBy(_fp.default.isEmpty, x);}; // ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";// ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAll = _fp.default.curryN(2, function (fns) {  for (var _len = arguments.length, x = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    x[_key - 1] = arguments[_key];  }  return _fp.default.flow(_fp.default.over(fns), _fp.default.mergeAll).apply(void 0, x);}); // customizer -> ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";var _len = arguments.length,    x = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";// customizer -> ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAllWith = _fp.default.curryN(3, function (customizer, fns) {  for (var _len2 = arguments.length, x = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {    x[_key2 - 2] = arguments[_key2];  }  return _fp.default.flow(_fp.default.over(fns), _fp.default.mergeAllWith(customizer)).apply(void 0, x);}); // ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}
"use strict";var _len2 = arguments.length,    x = new Array(_len2 > 2 ? _len2 - 2 : 0),    _key2 = 2;
"use strict";// ([f, g]) -> (x, y) -> {...f(x, y), ...g(x, y)}var mergeOverAllArrays = mergeOverAllWith(mergeArrays); // (x -> y) -> k -> {k: x} -> y
"use strict";// (x -> y) -> k -> {k: x} -> yvar getWith = _fp.default.curry(function (customizer, path, object) {  return customizer(_fp.default.get(path, object));}); // ({a} -> {b}) -> {a} -> {a, b}
"use strict";function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }// ({a} -> {b}) -> {a} -> {a, b}var expandObject = _fp.default.curry(function (transform, obj) {  return _objectSpread(_objectSpread({}, obj), transform(obj));}); // k -> (a -> {b}) -> {k: a} -> {a, b}
"use strict";// k -> (a -> {b}) -> {k: a} -> {a, b}var expandObjectBy = _fp.default.curry(function (key, fn, obj) {  return expandObject(getWith(fn, key))(obj);});
"use strict";var commonKeys = _fp.default.curryN(2, (0, _function.mapArgs)(_fp.default.keys, _fp.default.intersection));
"use strict";var findKeyIndexed = _fp.default.findKey.convert({  cap: false});
"use strict";var firstCommonKey = _fp.default.curry(function (x, y) {  return findKeyIndexed(function (val, key) {    return _fp.default.has(key, x);  }, y);});
"use strict";var _collection = require("./collection");
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _logic = require("./logic");
"use strict";var _array = require("./array");
"use strict";var _iterators = require("./iterators");
"use strict";var wrap = function wrap(pre, post, content) {  return (pre || '') + content + (post || pre || '');};
"use strict";var quote = _fp.default.partial(wrap, ['"', '"']);
"use strict";var parens = _fp.default.partial(wrap, ['(', ')']);
"use strict";var concatStrings = _fp.default.flow(_fp.default.compact, _fp.default.map(_fp.default.trim), _fp.default.join(' '));
"use strict";var trimStrings = (0, _collection.map)((0, _logic.when)(_fp.default.isString, _fp.default.trim)); // _.startCase does the trick, deprecate it!
"use strict";// _.startCase does the trick, deprecate it!var autoLabel = _fp.default.startCase;
"use strict";var autoLabelOption = function autoLabelOption(a) {  return {    value: (0, _logic.when)(_fp.default.isUndefined, a)(a.value),    label: a.label || autoLabel((0, _logic.when)(_fp.default.isUndefined, a)(a.value))  };};
"use strict";var autoLabelOptions = _fp.default.map(autoLabelOption);
"use strict";var toSentenceWith = _fp.default.curry(function (separator, lastSeparator, array) {  return _fp.default.flow((0, _array.intersperse)((0, _iterators.differentLast)(function () {    return separator;  }, function () {    return lastSeparator;  })), _fp.default.join(''))(array);});
"use strict";var toSentence = toSentenceWith(', ', ' and '); // ((array -> object), array) -> string -> string
"use strict";// ((array -> object), array) -> string -> stringvar uniqueStringWith = _fp.default.curry(function (cachizer, initialKeys) {  var f = function f(x) {    var result = x;    while (cache[result]) {      result = x + cache[x];      cache[x] += 1;    }    cache[result] = (cache[result] || 0) + 1;    return result;  };  var cache = cachizer(initialKeys);  f.cache = cache;  f.clear = function () {    cache = {};    f.cache = cache;  };  return f;});
"use strict";var f = function f(x) {  var result = x;  while (cache[result]) {    result = x + cache[x];    cache[x] += 1;  }  cache[result] = (cache[result] || 0) + 1;  return result;};
"use strict";var result = x;
"use strict";var cache = cachizer(initialKeys);
"use strict";var uniqueString = function uniqueString() {  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];  return uniqueStringWith(_fp.default.countBy(_fp.default.identity), arr);};
"use strict";var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _lang = require("./lang");
"use strict";// Corevar aspect = function aspect(_ref) {  var _ref$name = _ref.name,      name = _ref$name === void 0 ? 'aspect' : _ref$name,      _ref$init = _ref.init,      init = _ref$init === void 0 ? _fp.default.noop : _ref$init,      _ref$after = _ref.after,      after = _ref$after === void 0 ? _fp.default.noop : _ref$after,      _ref$before = _ref.before,      before = _ref$before === void 0 ? _fp.default.noop : _ref$before,      _ref$always = _ref.always,      always = _ref$always === void 0 ? _fp.default.noop : _ref$always,      _ref$onError = _ref.onError,      onError = _ref$onError === void 0 ? _lang.throws : _ref$onError;  return function (f) {    var _f$state = f.state,        state = _f$state === void 0 ? {} : _f$state;    init(state); // Trick to set function.name of anonymous function    var x = {      [name]() {        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {          args[_key] = arguments[_key];        }        var result;        var error;        return Promise.resolve().then(function () {          return before(args, state);        }).then(function () {          return f.apply(void 0, args);        }).then(function (r) {          result = r;        }).then(function () {          return after(result, state, args);        }).catch(function (e) {          return onError(e, state, args);        }).catch(function (e) {          error = e;        }).then(function () {          return always(state, args);        }).then(function () {          if (error) throw error;        }).then(function () {          return result;        });      }    };    x[name].state = state;    return x[name];  };};
"use strict";var _ref2 = _ref,    _ref2$name = _ref2.name,    name = _ref2$name === void 0 ? 'aspect' : _ref2$name,    _ref2$init = _ref2.init,    init = _ref2$init === void 0 ? _fp.default.noop : _ref2$init,    _ref2$after = _ref2.after,    after = _ref2$after === void 0 ? _fp.default.noop : _ref2$after,    _ref2$before = _ref2.before,    before = _ref2$before === void 0 ? _fp.default.noop : _ref2$before,    _ref2$always = _ref2.always,    always = _ref2$always === void 0 ? _fp.default.noop : _ref2$always,    _ref2$onError = _ref2.onError,    onError = _ref2$onError === void 0 ? _lang.throws : _ref2$onError;
"use strict";var _f = f,    _f$state = _f.state,    state = _f$state === void 0 ? {} : _f$state;
"use strict";// Trick to set function.name of anonymous functionvar x = {  [name]() {    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {      args[_key] = arguments[_key];    }    var result;    var error;    return Promise.resolve().then(function () {      return before(args, state);    }).then(function () {      return f.apply(void 0, args);    }).then(function (r) {      result = r;    }).then(function () {      return after(result, state, args);    }).catch(function (e) {      return onError(e, state, args);    }).catch(function (e) {      error = e;    }).then(function () {      return always(state, args);    }).then(function () {      if (error) throw error;    }).then(function () {      return result;    });  }};
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var result;
"use strict";var error;
"use strict";var aspectSync = function aspectSync(_ref2) {  var _ref2$name = _ref2.name,      name = _ref2$name === void 0 ? 'aspect' : _ref2$name,      _ref2$init = _ref2.init,      init = _ref2$init === void 0 ? _fp.default.noop : _ref2$init,      _ref2$after = _ref2.after,      after = _ref2$after === void 0 ? _fp.default.noop : _ref2$after,      _ref2$before = _ref2.before,      before = _ref2$before === void 0 ? _fp.default.noop : _ref2$before,      _ref2$always = _ref2.always,      always = _ref2$always === void 0 ? _fp.default.noop : _ref2$always,      _ref2$onError = _ref2.onError,      onError = _ref2$onError === void 0 ? _lang.throws : _ref2$onError;  return function (f) {    var _f$state = f.state,        state = _f$state === void 0 ? {} : _f$state;    init(state); // Trick to set function.name of anonymous function    var x = {      [name]() {        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {          args[_key2] = arguments[_key2];        }        try {          before(args, state);          var result = f.apply(void 0, args);          after(result, state, args);          return result;        } catch (e) {          onError(e, state, args);          throw e;        } finally {          always(state, args);        }      }    };    x[name].state = state;    return x[name];  };}; // Example Aspects
"use strict";var _ref = _ref2,    _ref$name = _ref.name,    name = _ref$name === void 0 ? 'aspect' : _ref$name,    _ref$init = _ref.init,    init = _ref$init === void 0 ? _fp.default.noop : _ref$init,    _ref$after = _ref.after,    after = _ref$after === void 0 ? _fp.default.noop : _ref$after,    _ref$before = _ref.before,    before = _ref$before === void 0 ? _fp.default.noop : _ref$before,    _ref$always = _ref.always,    always = _ref$always === void 0 ? _fp.default.noop : _ref$always,    _ref$onError = _ref.onError,    onError = _ref$onError === void 0 ? _lang.throws : _ref$onError;
"use strict";var _f = f,    _f$state = _f.state,    state = _f$state === void 0 ? {} : _f$state;
"use strict";// Trick to set function.name of anonymous functionvar x = {  [name]() {    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {      args[_key2] = arguments[_key2];    }    try {      before(args, state);      var result = f.apply(void 0, args);      after(result, state, args);      return result;    } catch (e) {      onError(e, state, args);      throw e;    } finally {      always(state, args);    }  }};
"use strict";var _len2 = arguments.length,    args = new Array(_len2),    _key2 = 0;
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var result = f.apply(void 0, _toConsumableArray(args));
"use strict";// Example Aspectsvar logs = function logs() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      logs: []    }),    after: function after(result, state) {      return state.logs.push(result);    },    name: 'logs'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var error = function error() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      error: null    }),    onError: (0, _conversion.setOn)('error'),    name: 'error'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var errors = function errors() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      errors: []    }),    onError: function onError(e, state) {      return state.errors.push(e);    },    name: 'errors'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var status = function status() {  var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;  return aspect({    init: extend({      status: null,      processing: false,      succeeded: false,      failed: false,      // Computed get/set properties don't work, probably because lodash extend methods don't support copying them      setStatus(x) {        this.status = x;        this.failed = x === 'failed';        this.succeeded = x === 'succeeded';        this.processing = x === 'processing';      }    }),    before(params, state) {      state.setStatus('processing');    },    after(result, state) {      state.setStatus('succeeded');    },    onError: (0, _lang.tapError)(function (e, state) {      state.setStatus('failed');    }),    name: 'status'  });};
"use strict";var extend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _conversion.defaultsOn;
"use strict";var clearStatus = function clearStatus() {  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;  return aspect({    always(state) {      if (timeout !== null) {        setTimeout(function () {          state.setStatus(null);        }, timeout);      }    },    name: 'clearStatus'  });}; // This is a function just for consistency
"use strict";var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
"use strict";// This is a function just for consistencyvar concurrency = function concurrency() {  return aspect({    before(params, state) {      if (state.processing) {        throw Error('Concurrent Runs Not Allowed');      }    },    name: 'concurrency'  });};
"use strict";var command = function command(extend, timeout) {  return _fp.default.flow(status(extend), clearStatus(timeout), concurrency(extend), error(extend));};
"use strict";var deprecate = function deprecate(subject, version, alternative) {  return aspectSync({    before: function before() {      return console.warn("`".concat(subject, "` is deprecated").concat(version ? " as of ".concat(version) : '').concat(alternative ? " in favor of `".concat(alternative, "`") : '', " ").concat(_fp.default.trim((Error().stack || '').split('\n')[3])));    }  });};
"use strict";var aspects = {  logs,  error,  errors,  status,  deprecate,  clearStatus,  concurrency,  command};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _aspect = require("./aspect");
"use strict";var noRearg = _fp.default.convert({  rearg: false});
"use strict";var mutable = _fp.default.convert({  immutable: false});
"use strict";var noCap = _fp.default.convert({  cap: false}); // Flips// ----------
"use strict";// Flips// ----------var getIn = noRearg.get;
"use strict";var hasIn = noRearg.has;
"use strict";var pickIn = noRearg.pick;
"use strict";var includesIn = noRearg.includes;
"use strict";var inversions = _fp.default.mapKeys(function (k) {  return "".concat(k, "In");}, noRearg); // Mutables// ----------
"use strict";// Mutables// ----------var extendOn = mutable.extend;
"use strict";var defaultsOn = mutable.defaults;
"use strict";var mergeOn = mutable.merge;
"use strict";var setOn = mutable.set; // Curry required until https://github.com/lodash/lodash/issues/3440 is resolved
"use strict";// Curry required until https://github.com/lodash/lodash/issues/3440 is resolvedvar unsetOn = _fp.default.curryN(2, mutable.unset);
"use strict";var pullOn = mutable.pull;
"use strict";var updateOn = mutable.update; // Uncaps// ------// Un-prefixed Deprecated
"use strict";// Uncaps// ------// Un-prefixed Deprecatedvar reduce = _aspect.aspects.deprecate('reduce', '1.28.0', 'reduceIndexed')(noCap.reduce);
"use strict";var mapValues = _aspect.aspects.deprecate('mapValues', '1.28.0', 'mapValuesIndexed')(noCap.mapValues);
"use strict";var each = _aspect.aspects.deprecate('each', '1.28.0', 'eachIndexed')(noCap.each);
"use strict";var mapIndexed = noCap.map;
"use strict";var findIndexed = noCap.find;
"use strict";var eachIndexed = noCap.each;
"use strict";var reduceIndexed = noCap.reduce;
"use strict";var pickByIndexed = noCap.pickBy;
"use strict";var mapValuesIndexed = noCap.mapValues;
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _tree = require("./tree");
"use strict";var throws = function throws(x) {  throw x;};
"use strict";var tapError = function tapError(f) {  return function (e) {    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {      args[_key - 1] = arguments[_key];    }    f.apply(void 0, [e].concat(args));    throw e;  };};
"use strict";var _len = arguments.length,    args = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";var isNotNil = _fp.default.negate(_fp.default.isNil);
"use strict";var exists = isNotNil;
"use strict";var isMultiple = function isMultiple(x) {  return (x || []).length > 1;};
"use strict";var append = _fp.default.curry(function (x, y) {  return y + x;}); // True for everything except null, undefined, '', [], and {}
"use strict";// True for everything except null, undefined, '', [], and {}var isBlank = _fp.default.overSome([_fp.default.isNil, _fp.default.isEqual(''), _fp.default.isEqual([]), _fp.default.isEqual({})]);
"use strict";var isNotBlank = _fp.default.negate(isBlank);
"use strict";var isBlankDeep = function isBlankDeep(combinator) {  return function (x) {    return combinator(isBlank, (0, _tree.tree)().leaves(x));  };};
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _function = require("./function");
"use strict";var _lang = require("./lang");
"use strict";// ([f, g]) -> !f(x) && !g(x)var overNone = _fp.default.flow(_fp.default.overSome, _fp.default.negate);
"use strict";var boolIteratee = function boolIteratee(x) {  return _fp.default.isBoolean(x) || _fp.default.isNil(x) ? function () {    return x;  } : _fp.default.iteratee(x);}; // Port from Ramda
"use strict";// Port from Ramdavar ifElse = _fp.default.curry(function (condition, onTrue, onFalse, x) {  return boolIteratee(condition)(x) ? (0, _function.callOrReturn)(onTrue, x) : (0, _function.callOrReturn)(onFalse, x);});
"use strict";var when = _fp.default.curry(function (condition, t, x) {  return ifElse(condition, t, _fp.default.identity, x);});
"use strict";var unless = _fp.default.curry(function (condition, f, x) {  return ifElse(condition, _fp.default.identity, f, x);});
"use strict";var whenExists = when(_lang.exists);
"use strict";var whenTruthy = when(Boolean);
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _array = require("./array");
"use strict";var _collection = require("./collection");
"use strict";var testRegex = _fp.default.curry(function (regex, str) {  return new RegExp(regex).test(str);});
"use strict";var makeRegex = function makeRegex(options) {  return function (text) {    return RegExp(text, options);  };};
"use strict";var makeAndTest = function makeAndTest(options) {  return _fp.default.flow(makeRegex(options), testRegex);};
"use strict";var anyWordToRegexp = _fp.default.flow(_fp.default.words, _fp.default.join('|'));
"use strict";var wordsToRegexp = _fp.default.flow(_fp.default.words, _fp.default.map(function (x) {  return "(?=.*".concat(x, ".*)");}), _fp.default.join(''), function (x) {  return ".*".concat(x, ".*");});
"use strict";var matchWords = _fp.default.curry(function (buildRegex, x) {  // Not inlining so that we don't create the regexp every time  var regexp = RegExp(buildRegex(x), 'gi');  return function (y) {    return !!(y && y.match(regexp));  };});
"use strict";// Not inlining so that we don't create the regexp every timevar regexp = RegExp(buildRegex(x), 'gi');
"use strict";var matchAllWords = matchWords(wordsToRegexp);
"use strict";var matchAnyWord = matchWords(anyWordToRegexp);
"use strict";var allMatches = _fp.default.curry(function (regexStr, str) {  var matched;  var regex = new RegExp(regexStr, 'g');  var result = [];  while ((matched = regex.exec(str)) !== null) {    result.push({      text: matched[0],      start: matched.index,      end: regex.lastIndex    });  }  return result;});
"use strict";var matched;
"use strict";var regex = new RegExp(regexStr, 'g');
"use strict";var result = [];
"use strict";var postings = _fp.default.curry(function (regex, str) {  var match = regex.exec(str);  var result = [];  if (regex.flags.indexOf('g') < 0 && match) {    result.push([match.index, match.index + match[0].length]);  } else {    while (match) {      result.push([match.index, regex.lastIndex]);      match = regex.exec(str);    }  }  return result;});
"use strict";var match = regex.exec(str);
"use strict";var result = [];
"use strict";var postingsForWords = _fp.default.curry(function (string, str) {  return _fp.default.reduce(function (result, word) {    return (0, _array.push)(postings(RegExp(word, 'gi'), str), result);  }, [])(_fp.default.words(string));});
"use strict";var highlightFromPostings = _fp.default.curry(function (start, end, postings, str) {  var offset = 0;  _fp.default.each(function (posting) {    str = (0, _collection.insertAtIndex)(posting[0] + offset, start, str);    offset += start.length;    str = (0, _collection.insertAtIndex)(posting[1] + offset, end, str);    offset += end.length;  }, (0, _array.mergeRanges)(postings));  return str;});
"use strict";var offset = 0;
"use strict";var highlight = _fp.default.curry(function (start, end, pattern, input) {  return highlightFromPostings(start, end, _fp.default.isRegExp(pattern) ? postings(pattern, input) : _fp.default.flatten(postingsForWords(pattern, input)), input);});
"use strict";var _fp = _interopRequireDefault(require("lodash/fp"));
"use strict";var _conversion = require("./conversion");
"use strict";var _array = require("./array");
"use strict";var isTraversable = function isTraversable(x) {  return _fp.default.isArray(x) || _fp.default.isPlainObject(x);};
"use strict";var traverse = function traverse(x) {  return isTraversable(x) && !_fp.default.isEmpty(x) && x;};
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var walk = function walk() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (pre) {    var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;    var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];    var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];    return function (tree, index) {      return pre(tree, index, parents, parentIndexes) || (0, _conversion.findIndexed)(walk(next)(pre, post, [tree].concat(_toConsumableArray(parents)), [index].concat(_toConsumableArray(parentIndexes))), next(tree, index, parents, parentIndexes) || []) || post(tree, index, parents, parentIndexes);    };  };}; // async/await is so much cleaner but causes regeneratorRuntime shenanigans// export let findIndexedAsync = async (f, data) => {//   for (let key in data) {//     if (await f(data[key], key, data)) return data[key]//   }// }// The general idea here is to keep popping off key/value pairs until we hit something that matches
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;
"use strict";var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
"use strict";var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }// async/await is so much cleaner but causes regeneratorRuntime shenanigans// export let findIndexedAsync = async (f, data) => {//   for (let key in data) {//     if (await f(data[key], key, data)) return data[key]//   }// }// The general idea here is to keep popping off key/value pairs until we hit something that matchesvar findIndexedAsync = function findIndexedAsync(f, data) {  var remaining = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _fp.default.toPairs(data);  if (!remaining.length) return;  var _remaining = _toArray(remaining),      _remaining$ = _slicedToArray(_remaining[0], 2),      key = _remaining$[0],      val = _remaining$[1],      rest = _remaining.slice(1);  return Promise.resolve(f(val, key, data)).then(function (result) {    return result ? val : rest.length ? findIndexedAsync(f, data, rest) : undefined;  });};
"use strict";var remaining = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _fp.default.toPairs(data);
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _remaining = remaining,    _remaining2 = _toArray(_remaining),    _remaining2$ = _slicedToArray(_remaining2[0], 2),    key = _remaining2$[0],    val = _remaining2$[1],    rest = _remaining2.slice(1);
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var walkAsync = function walkAsync() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (pre) {    var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;    var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];    var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];    return function (tree, index) {      return Promise.resolve(pre(tree, index, parents, parentIndexes)).then(function (preResult) {        return preResult || findIndexedAsync(walkAsync(next)(pre, post, [tree].concat(_toConsumableArray(parents)), [index].concat(_toConsumableArray(parentIndexes))), next(tree, index, parents, parentIndexes) || []);      }).then(function (stepResult) {        return stepResult || post(tree, index, parents, parentIndexes);      });    };  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.noop;
"use strict";var parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
"use strict";var parentIndexes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
"use strict";var transformTree = function transformTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (f, x) {    var result = _fp.default.cloneDeep(x);    walk(next)(f)(result);    return result;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var result = _fp.default.cloneDeep(x);
"use strict";var reduceTree = function reduceTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (f, result, tree) {    walk(next)(function () {      for (var _len = arguments.length, x = new Array(_len), _key = 0; _key < _len; _key++) {        x[_key] = arguments[_key];      }      result = f.apply(void 0, [result].concat(x));    })(tree);    return result;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len = arguments.length,    x = new Array(_len),    _key = 0;
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var writeProperty = function writeProperty() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function (node, index, _ref) {    var _ref2 = _slicedToArray(_ref, 1),        parent = _ref2[0];    next(parent)[index] = node;  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }var _ref2 = _ref,    _ref3 = _slicedToArray(_ref2, 1),    parent = _ref3[0];
"use strict";var mapTree = function mapTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);  return _fp.default.curry(function (mapper, tree) {    return transformTree(next)(function (node, i, parents) {      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {        args[_key2 - 3] = arguments[_key2];      }      if (parents.length) writeNode.apply(void 0, [mapper.apply(void 0, [node, i, parents].concat(args)), i, parents].concat(args));    })(mapper(tree));  } // run mapper on root, and skip root in traversal  );};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);
"use strict";var _len2 = arguments.length,    args = new Array(_len2 > 3 ? _len2 - 3 : 0),    _key2 = 3;
"use strict";var mapTreeLeaves = function mapTreeLeaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);  return _fp.default.curry(function (mapper, tree) {    return (// this unless wrapping can be done in user land, this is pure convenience      // mapTree(next, writeNode)(F.unless(next, mapper), tree)      mapTree(next, writeNode)(function (node) {        return next(node) ? node : mapper(node);      }, tree)    );  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var writeNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : writeProperty(next);
"use strict";var treeToArrayBy = function treeToArrayBy() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (fn, tree) {    return reduceTree(next)(function (r) {      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {        args[_key3 - 1] = arguments[_key3];      }      return (0, _array.push)(fn.apply(void 0, args), r);    }, [], tree);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len3 = arguments.length,    args = new Array(_len3 > 1 ? _len3 - 1 : 0),    _key3 = 1;
"use strict";var treeToArray = function treeToArray() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return treeToArrayBy(next)(function (x) {    return x;  });}; // This could reuse treeToArrayBy and just reject traversable elements after, but this is more efficient// We can potentially unify these with tree transducers
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";// This could reuse treeToArrayBy and just reject traversable elements after, but this is more efficient// We can potentially unify these with tree transducersvar leavesBy = function leavesBy() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (fn, tree) {    return reduceTree(next)(function (r, node) {      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {        args[_key4 - 2] = arguments[_key4];      }      return next(node) ? r : (0, _array.push)(fn.apply(void 0, [node].concat(args)), r);    }, [], tree);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var _len4 = arguments.length,    args = new Array(_len4 > 2 ? _len4 - 2 : 0),    _key4 = 2;
"use strict";var leaves = function leaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return leavesBy(next)(function (x) {    return x;  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var treeLookup = function treeLookup() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;  return _fp.default.curry(function (path, tree) {    return _fp.default.reduce(function (tree, path) {      return (0, _conversion.findIndexed)(buildIteratee(path), next(tree));    }, tree, path);  });};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;
"use strict";var keyTreeByWith = function keyTreeByWith() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.curry(function (transformer, groupIteratee, x) {    return _fp.default.flow(treeToArrayBy(next)(_fp.default.iteratee(groupIteratee)), _fp.default.uniq, _fp.default.keyBy(_fp.default.identity), _fp.default.mapValues(function (group) {      return transformTree(next)(function (node) {        var matches = _fp.default.iteratee(groupIteratee)(node) === group;        transformer(node, matches, group);      }, x);    }))(x);  });}; // Flat Tree
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var matches = _fp.default.iteratee(groupIteratee)(node) === group;
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }// Flat Treevar treeKeys = function treeKeys(x, i, xs, is) {  return [i].concat(_toConsumableArray(is));};
"use strict";function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }var treeValues = function treeValues(x, i, xs) {  return [x].concat(_toConsumableArray(xs));};
"use strict";var treePath = function treePath() {  var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treeKeys;  var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _array.dotEncoder;  return function () {    return (encoder.encode || encoder)(build.apply(void 0, arguments).reverse());  };};
"use strict";var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treeKeys;
"use strict";var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _array.dotEncoder;
"use strict";var propTreePath = function propTreePath(prop) {  return treePath(_fp.default.flow(treeValues, _fp.default.map(prop)), _array.slashEncoder);};
"use strict";var flattenTree = function flattenTree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return function () {    var buildPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treePath();    return reduceTree(next)(function (result, node) {      for (var _len5 = arguments.length, x = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {        x[_key5 - 2] = arguments[_key5];      }      return _fp.default.set([buildPath.apply(void 0, [node].concat(x))], node, result);    }, {});  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : treePath();
"use strict";var _len5 = arguments.length,    x = new Array(_len5 > 2 ? _len5 - 2 : 0),    _key5 = 2;
"use strict";var flatLeaves = function flatLeaves() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  return _fp.default.reject(next);};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var tree = function tree() {  var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;  var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;  var writeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : writeProperty(next);  return {    walk: walk(next),    walkAsync: walkAsync(next),    transform: transformTree(next),    reduce: reduceTree(next),    toArrayBy: treeToArrayBy(next),    toArray: treeToArray(next),    leaves: leaves(next),    leavesBy: leavesBy(next),    lookup: treeLookup(next, buildIteratee),    keyByWith: keyTreeByWith(next),    traverse: next,    flatten: flattenTree(next),    flatLeaves: flatLeaves(next),    map: mapTree(next, writeNode),    mapLeaves: mapTreeLeaves(next, writeNode)  };};
"use strict";var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : traverse;
"use strict";var buildIteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fp.default.identity;
"use strict";var writeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : writeProperty(next);
"use strict";var _createMathOperation = _interopRequireDefault(require("./.internal/createMathOperation.js"));
"use strict";/** * Adds two numbers. * * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * add(6, 4) * // => 10 */var add = (0, _createMathOperation.default)(function (augend, addend) {  return augend + addend;}, 0);
"use strict";var _default = add;
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var _default = after;
"use strict";/** * The opposite of `before`. This method creates a function that invokes * `func` once it's called `n` or more times. * * @since 0.1.0 * @category Function * @param {number} n The number of calls before `func` is invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * const saves = ['profile', 'settings'] * const done = after(saves.length, () => console.log('done saving!')) * * forEach(saves, type => asyncSave({ 'type': type, 'complete': done })) * // => Logs 'done saving!' after the two async saves have completed. */function after(n, func) {  if (typeof func !== 'function') {    throw new TypeError('Expected a function');  }  n = n || 0;  return function () {    if (--n < 1) {      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {        args[_key] = arguments[_key];      }      return func.apply(this, args);    }  };}
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var _default = after;
"use strict";var _baseAt = _interopRequireDefault(require("./.internal/baseAt.js"));
"use strict";var _baseFlatten = _interopRequireDefault(require("./.internal/baseFlatten.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Creates an array of values corresponding to `paths` of `object`. * * @since 1.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Array} Returns the picked values. * @example * * const object = { 'a': [{ 'b': { 'c': 3 } }, 4] } * * at(object, ['a[0].b.c', 'a[1]']) * // => [3, 4] */var at = function at(object) {  for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    paths[_key - 1] = arguments[_key];  }  return (0, _baseAt.default)(object, (0, _baseFlatten.default)(paths, 1));};
"use strict";var _len = arguments.length,    paths = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";var _default = at;
"use strict";var _isError = _interopRequireDefault(require("./isError.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invoke `func` with. * @returns {*} Returns the `func` result or error object. * @example * * // Avoid throwing errors for invalid selectors. * const elements = attempt(selector => *   document.querySelectorAll(selector), '>_>') * * if (isError(elements)) { *   elements = [] * } */function attempt(func) {  try {    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {      args[_key - 1] = arguments[_key];    }    return func.apply(void 0, args);  } catch (e) {    return (0, _isError.default)(e) ? e : new Error(e);  }}
"use strict";var _len = arguments.length,    args = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";var _default = attempt;
"use strict";/** * Creates a function that invokes `func`, with the `this` binding and arguments * of the created function, while it's called less than `n` times. Subsequent * calls to the created function return the result of the last `func` invocation. * * @since 3.0.0 * @category Function * @param {number} n The number of calls at which `func` is no longer invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * jQuery(element).on('click', before(5, addContactToList)) * // => Allows adding up to 4 contacts to the list. */function before(n, func) {  var result;  if (typeof func !== 'function') {    throw new TypeError('Expected a function');  }  return function () {    if (--n > 0) {      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {        args[_key] = arguments[_key];      }      result = func.apply(this, args);    }    if (n <= 1) {      func = undefined;    }    return result;  };}
"use strict";var result;
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var _default = before;
"use strict";var _upperFirst = _interopRequireDefault(require("./upperFirst.js"));
"use strict";var _words = _interopRequireDefault(require("./words.js"));
"use strict";var _toString = _interopRequireDefault(require("./toString.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase). * * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the camel cased string. * @see lowerCase, kebabCase, snakeCase, startCase, upperCase, upperFirst * @example * * camelCase('Foo Bar') * // => 'fooBar' * * camelCase('--foo-bar--') * // => 'fooBar' * * camelCase('__FOO_BAR__') * // => 'fooBar' */var camelCase = function camelCase(string) {  return (0, _words.default)((0, _toString.default)(string).replace(/['\u2019]/g, '')).reduce(function (result, word, index) {    word = word.toLowerCase();    return result + (index ? (0, _upperFirst.default)(word) : word);  }, '');};
"use strict";var _default = camelCase;
"use strict";var _upperFirst = _interopRequireDefault(require("./upperFirst.js"));
"use strict";var _toString = _interopRequireDefault(require("./toString.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Converts the first character of `string` to upper case and the remaining * to lower case. * * @since 3.0.0 * @category String * @param {string} [string=''] The string to capitalize. * @returns {string} Returns the capitalized string. * @example * * capitalize('FRED') * // => 'Fred' */var capitalize = function capitalize(string) {  return (0, _upperFirst.default)((0, _toString.default)(string).toLowerCase());};
"use strict";var _default = capitalize;
"use strict";/** * Casts `value` as an array if it's not one. * * @since 4.4.0 * @category Lang * @param {*} value The value to inspect. * @returns {Array} Returns the cast array. * @example * * castArray(1) * // => [1] * * castArray({ 'a': 1 }) * // => [{ 'a': 1 }] * * castArray('abc') * // => ['abc'] * * castArray(null) * // => [null] * * castArray(undefined) * // => [undefined] * * castArray() * // => [] * * const array = [1, 2, 3] * console.log(castArray(array) === array) * // => true */function castArray() {  if (!arguments.length) {    return [];  }  var value = arguments.length <= 0 ? undefined : arguments[0];  return Array.isArray(value) ? value : [value];}
"use strict";var value = arguments.length <= 0 ? undefined : arguments[0];
"use strict";var _default = castArray;
"use strict";var _createRound = _interopRequireDefault(require("./.internal/createRound.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Computes `number` rounded up to `precision`. (Round up: the smallest integer greater than or equal to a given number.) * * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * ceil(4.006) * // => 5 * * ceil(6.004, 2) * // => 6.01 * * ceil(6040, -2) * // => 6100 */var ceil = (0, _createRound.default)('ceil');
"use strict";var _default = ceil;
"use strict";var _slice = _interopRequireDefault(require("./slice.js"));
"use strict";var _toInteger = _interopRequireDefault(require("./toInteger.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Creates an array of elements split into groups the length of `size`. * If `array` can't be split evenly, the final chunk will be the remaining * elements. * * @since 3.0.0 * @category Array * @param {Array} array The array to process. * @param {number} [size=1] The length of each chunk * @returns {Array} Returns the new array of chunks. * @example * * chunk(['a', 'b', 'c', 'd'], 2) * // => [['a', 'b'], ['c', 'd']] * * chunk(['a', 'b', 'c', 'd'], 3) * // => [['a', 'b', 'c'], ['d']] */function chunk(array) {  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;  size = Math.max((0, _toInteger.default)(size), 0);  var length = array == null ? 0 : array.length;  if (!length || size < 1) {    return [];  }  var index = 0;  var resIndex = 0;  var result = new Array(Math.ceil(length / size));  while (index < length) {    result[resIndex++] = (0, _slice.default)(array, index, index += size);  }  return result;}
"use strict";var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
"use strict";var length = array == null ? 0 : array.length;
"use strict";var index = 0;
"use strict";var resIndex = 0;
"use strict";var result = new Array(Math.ceil(length / size));
"use strict";var _default = chunk;
"use strict";/** * Clamps `number` within the inclusive `lower` and `upper` bounds. * * @since 4.0.0 * @category Number * @param {number} number The number to clamp. * @param {number} lower The lower bound. * @param {number} upper The upper bound. * @returns {number} Returns the clamped number. * @example * * clamp(-10, -5, 5) * // => -5 * * clamp(10, -5, 5) * // => 5 */function clamp(number, lower, upper) {  number = +number;  lower = +lower;  upper = +upper;  lower = lower === lower ? lower : 0;  upper = upper === upper ? upper : 0;  if (number === number) {    number = number <= upper ? number : upper;    number = number >= lower ? number : lower;  }  return number;}
"use strict";var _default = clamp;
"use strict";var _baseClone = _interopRequireDefault(require("./.internal/baseClone.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to compose bitmasks for cloning. */var CLONE_SYMBOLS_FLAG = 4;/** * Creates a shallow clone of `value`. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers, `Object` objects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties of `arguments` objects are cloned * as plain objects. Object inheritance is preserved. An empty object is * returned for uncloneable values such as error objects, functions, DOM nodes, * and WeakMaps. * * @since 0.1.0 * @category Lang * @param {*} value The value to clone. * @returns {*} Returns the cloned value. * @see cloneDeep * @example * * const objects = [{ 'a': 1 }, { 'b': 2 }] * * const shallow = clone(objects) * console.log(shallow[0] === objects[0]) * // => true */
"use strict";/** * Creates a shallow clone of `value`. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers, `Object` objects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties of `arguments` objects are cloned * as plain objects. Object inheritance is preserved. An empty object is * returned for uncloneable values such as error objects, functions, DOM nodes, * and WeakMaps. * * @since 0.1.0 * @category Lang * @param {*} value The value to clone. * @returns {*} Returns the cloned value. * @see cloneDeep * @example * * const objects = [{ 'a': 1 }, { 'b': 2 }] * * const shallow = clone(objects) * console.log(shallow[0] === objects[0]) * // => true */function clone(value) {  return (0, _baseClone.default)(value, CLONE_SYMBOLS_FLAG);}
"use strict";var _default = clone;
"use strict";var _baseClone = _interopRequireDefault(require("./.internal/baseClone.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG = 1;
"use strict";var CLONE_SYMBOLS_FLAG = 4;/** * This method is like `clone` except that it recursively clones `value`. * Object inheritance is preserved. * * @since 1.0.0 * @category Lang * @param {*} value The value to recursively clone. * @returns {*} Returns the deep cloned value. * @see clone * @example * * const objects = [{ 'a': 1 }, { 'b': 2 }] * * const deep = cloneDeep(objects) * console.log(deep[0] === objects[0]) * // => false */
"use strict";/** * This method is like `clone` except that it recursively clones `value`. * Object inheritance is preserved. * * @since 1.0.0 * @category Lang * @param {*} value The value to recursively clone. * @returns {*} Returns the deep cloned value. * @see clone * @example * * const objects = [{ 'a': 1 }, { 'b': 2 }] * * const deep = cloneDeep(objects) * console.log(deep[0] === objects[0]) * // => false */function cloneDeep(value) {  return (0, _baseClone.default)(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);}
"use strict";var _default = cloneDeep;
"use strict";var _baseClone = _interopRequireDefault(require("./.internal/baseClone.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG = 1;
"use strict";var CLONE_SYMBOLS_FLAG = 4;/** * This method is like `cloneWith` except that it recursively clones `value`. * The customizer is invoked with up to four arguments * (value [, index|key, object, stack]). * * @since 4.0.0 * @category Lang * @param {*} value The value to recursively clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the deep cloned value. * @see cloneWith * @example * * function customizer(value) { *   if (isElement(value)) { *     return value.cloneNode(true) *   } * } * * const el = cloneDeepWith(document.body, customizer) * * console.log(el === document.body) * // => false * console.log(el.nodeName) * // => 'BODY' * console.log(el.childNodes.length) * // => 20 */
"use strict";/** * This method is like `cloneWith` except that it recursively clones `value`. * The customizer is invoked with up to four arguments * (value [, index|key, object, stack]). * * @since 4.0.0 * @category Lang * @param {*} value The value to recursively clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the deep cloned value. * @see cloneWith * @example * * function customizer(value) { *   if (isElement(value)) { *     return value.cloneNode(true) *   } * } * * const el = cloneDeepWith(document.body, customizer) * * console.log(el === document.body) * // => false * console.log(el.nodeName) * // => 'BODY' * console.log(el.childNodes.length) * // => 20 */function cloneDeepWith(value, customizer) {  customizer = typeof customizer === 'function' ? customizer : undefined;  return (0, _baseClone.default)(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);}
"use strict";var _default = cloneDeepWith;
"use strict";var _baseClone = _interopRequireDefault(require("./.internal/baseClone.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to compose bitmasks for cloning. */var CLONE_SYMBOLS_FLAG = 4;/** * This method is like `clone` except that it accepts `customizer` which * is invoked to produce the cloned value. If `customizer` returns `undefined`, * cloning is handled by the method instead. The `customizer` is invoked with * one argument (value). * * @since 4.0.0 * @category Lang * @param {*} value The value to clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the cloned value. * @see cloneDeepWith * @example * * function customizer(value) { *   if (isElement(value)) { *     return value.cloneNode(false) *   } * } * * const el = cloneWith(document.body, customizer) * * console.log(el === document.body) * // => false * console.log(el.nodeName) * // => 'BODY' * console.log(el.childNodes.length) * // => 0 */
"use strict";/** * This method is like `clone` except that it accepts `customizer` which * is invoked to produce the cloned value. If `customizer` returns `undefined`, * cloning is handled by the method instead. The `customizer` is invoked with * one argument (value). * * @since 4.0.0 * @category Lang * @param {*} value The value to clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the cloned value. * @see cloneDeepWith * @example * * function customizer(value) { *   if (isElement(value)) { *     return value.cloneNode(false) *   } * } * * const el = cloneWith(document.body, customizer) * * console.log(el === document.body) * // => false * console.log(el.nodeName) * // => 'BODY' * console.log(el.childNodes.length) * // => 0 */function cloneWith(value, customizer) {  customizer = typeof customizer === 'function' ? customizer : undefined;  return (0, _baseClone.default)(value, CLONE_SYMBOLS_FLAG, customizer);}
"use strict";var _default = cloneWith;
"use strict";function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }/** * Creates an array with all falsey values removed. The values `false`, `null`, * `0`, `""`, `undefined`, and `NaN` are falsey. * * @since 0.1.0 * @category Array * @param {Array} array The array to compact. * @returns {Array} Returns the new array of filtered values. * @example * * compact([0, 1, false, 2, '', 3]) * // => [1, 2, 3] */function compact(array) {  var resIndex = 0;  var result = [];  if (array == null) {    return result;  }  var _iterator = _createForOfIteratorHelper(array),      _step;  try {    for (_iterator.s(); !(_step = _iterator.n()).done;) {      var value = _step.value;      if (value) {        result[resIndex++] = value;      }    }  } catch (err) {    _iterator.e(err);  } finally {    _iterator.f();  }  return result;}
"use strict";var resIndex = 0;
"use strict";var result = [];
"use strict";var _map = _interopRequireDefault(require("./map.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }/** * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * const func = cond([ *   [matches({ 'a': 1 }),         () => 'matches A'], *   [conforms({ 'b': isNumber }), () => 'matches B'], *   [() => true,                  () => 'no match'] * ]) * * func({ 'a': 1, 'b': 2 }) * // => 'matches A' * * func({ 'a': 0, 'b': 1 }) * // => 'matches B' * * func({ 'a': '1', 'b': '2' }) * // => 'no match' */function cond(pairs) {  var _this = this;  var length = pairs == null ? 0 : pairs.length;  pairs = !length ? [] : (0, _map.default)(pairs, function (pair) {    if (typeof pair[1] !== 'function') {      throw new TypeError('Expected a function');    }    return [pair[0], pair[1]];  });  return function () {    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {      args[_key] = arguments[_key];    }    var _iterator = _createForOfIteratorHelper(pairs),        _step;    try {      for (_iterator.s(); !(_step = _iterator.n()).done;) {        var pair = _step.value;        if (pair[0].apply(_this, args)) {          return pair[1].apply(_this, args);        }      }    } catch (err) {      _iterator.e(err);    } finally {      _iterator.f();    }  };}
"use strict";var _this = void 0;
"use strict";var length = pairs == null ? 0 : pairs.length;
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var _baseClone = _interopRequireDefault(require("./.internal/baseClone.js"));
"use strict";var _baseConforms = _interopRequireDefault(require("./.internal/baseConforms.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG = 1;/** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `conformsTo` with * `source` partially applied. * * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * const objects = [ *   { 'a': 2, 'b': 1 }, *   { 'a': 1, 'b': 2 } * ] * * filter(objects, conforms({ 'b': function(n) { return n > 1 } })) * // => [{ 'a': 1, 'b': 2 }] */
"use strict";/** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `conformsTo` with * `source` partially applied. * * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * const objects = [ *   { 'a': 2, 'b': 1 }, *   { 'a': 1, 'b': 2 } * ] * * filter(objects, conforms({ 'b': function(n) { return n > 1 } })) * // => [{ 'a': 1, 'b': 2 }] */function conforms(source) {  return (0, _baseConforms.default)((0, _baseClone.default)(source, CLONE_DEEP_FLAG));}
"use strict";var _default = conforms;
"use strict";var _baseConformsTo = _interopRequireDefault(require("./.internal/baseConformsTo.js"));
"use strict";var _keys = _interopRequireDefault(require("./keys.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Checks if `object` conforms to `source` by invoking the predicate * properties of `source` with the corresponding property values of `object`. * * **Note:** This method is equivalent to `conforms` when `source` is * partially applied. * * @since 4.14.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property predicates to conform to. * @returns {boolean} Returns `true` if `object` conforms, else `false`. * @example * * const object = { 'a': 1, 'b': 2 } * * conformsTo(object, { 'b': function(n) { return n > 1 } }) * // => true * * conformsTo(object, { 'b': function(n) { return n > 2 } }) * // => false */function conformsTo(object, source) {  return source == null || (0, _baseConformsTo.default)(object, source, (0, _keys.default)(source));}
"use strict";var _default = conformsTo;
"use strict";var _baseAssignValue = _interopRequireDefault(require("./.internal/baseAssignValue.js"));
"use strict";var _reduce = _interopRequireDefault(require("./reduce.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to check objects for own properties. */var hasOwnProperty = Object.prototype.hasOwnProperty;/** * Creates an object composed of keys generated from the results of running * each element of `collection` thru `iteratee`. The corresponding value of * each key is the number of times the key was returned by `iteratee`. The * iteratee is invoked with one argument: (value). * * @since 0.5.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} iteratee The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * const users = [ *   { 'user': 'barney', 'active': true }, *   { 'user': 'betty', 'active': true }, *   { 'user': 'fred', 'active': false } * ] * * countBy(users, value => value.active); * // => { 'true': 2, 'false': 1 } */
"use strict";/** * Creates an object composed of keys generated from the results of running * each element of `collection` thru `iteratee`. The corresponding value of * each key is the number of times the key was returned by `iteratee`. The * iteratee is invoked with one argument: (value). * * @since 0.5.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} iteratee The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * const users = [ *   { 'user': 'barney', 'active': true }, *   { 'user': 'betty', 'active': true }, *   { 'user': 'fred', 'active': false } * ] * * countBy(users, value => value.active); * // => { 'true': 2, 'false': 1 } */function countBy(collection, iteratee) {  return (0, _reduce.default)(collection, function (result, value, key) {    key = iteratee(value);    if (hasOwnProperty.call(result, key)) {      ++result[key];    } else {      (0, _baseAssignValue.default)(result, key, 1);    }    return result;  }, {});}
"use strict";var _default = countBy;
"use strict";/** * Creates an object that inherits from the `prototype` object. If a * `properties` object is given, its own enumerable string keyed properties * are assigned to the created object. * * @since 2.3.0 * @category Object * @param {Object} prototype The object to inherit from. * @param {Object} [properties] The properties to assign to the object. * @returns {Object} Returns the new object. * @example * * function Shape() { *   this.x = 0 *   this.y = 0 * } * * function Circle() { *   Shape.call(this) * } * * Circle.prototype = create(Shape.prototype, { *   'constructor': Circle * }) * * const circle = new Circle * circle instanceof Circle * // => true * * circle instanceof Shape * // => true */function create(prototype, properties) {  prototype = prototype === null ? null : Object(prototype);  var result = Object.create(prototype);  return properties == null ? result : Object.assign(result, properties);}
"use strict";var result = Object.create(prototype);
"use strict";var _default = create;
"use strict";var _isObject = _interopRequireDefault(require("./isObject.js"));
"use strict";var _root = _interopRequireDefault(require("./.internal/root.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * Creates a debounced function that delays invoking `func` until after `wait` * milliseconds have elapsed since the last time the debounced function was * invoked, or until the next browser frame is drawn. The debounced function * comes with a `cancel` method to cancel delayed `func` invocations and a * `flush` method to immediately invoke them. Provide `options` to indicate * whether `func` should be invoked on the leading and/or trailing edge of the * `wait` timeout. The `func` is invoked with the last arguments provided to the * debounced function. Subsequent calls to the debounced function return the * result of the last `func` invocation. * * **Note:** If `leading` and `trailing` options are `true`, `func` is * invoked on the trailing edge of the timeout only if the debounced function * is invoked more than once during the `wait` timeout. * * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred * until the next tick, similar to `setTimeout` with a timeout of `0`. * * If `wait` is omitted in an environment with `requestAnimationFrame`, `func` * invocation will be deferred until the next frame is drawn (typically about * 16ms). * * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between `debounce` and `throttle`. * * @since 0.1.0 * @category Function * @param {Function} func The function to debounce. * @param {number} [wait=0] *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is *  used (if available). * @param {Object} [options={}] The options object. * @param {boolean} [options.leading=false] *  Specify invoking on the leading edge of the timeout. * @param {number} [options.maxWait] *  The maximum time `func` is allowed to be delayed before it's invoked. * @param {boolean} [options.trailing=true] *  Specify invoking on the trailing edge of the timeout. * @returns {Function} Returns the new debounced function. * @example * * // Avoid costly calculations while the window size is in flux. * jQuery(window).on('resize', debounce(calculateLayout, 150)) * * // Invoke `sendMail` when clicked, debouncing subsequent calls. * jQuery(element).on('click', debounce(sendMail, 300, { *   'leading': true, *   'trailing': false * })) * * // Ensure `batchLog` is invoked once after 1 second of debounced calls. * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 }) * const source = new EventSource('/stream') * jQuery(source).on('message', debounced) * * // Cancel the trailing debounced invocation. * jQuery(window).on('popstate', debounced.cancel) * * // Check for pending invocations. * const status = debounced.pending() ? "Pending..." : "Ready" */function debounce(func, wait, options) {  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime;  var lastInvokeTime = 0;  var leading = false;  var maxing = false;  var trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.  var useRAF = !wait && wait !== 0 && typeof _root.default.requestAnimationFrame === 'function';  if (typeof func !== 'function') {    throw new TypeError('Expected a function');  }  wait = +wait || 0;  if ((0, _isObject.default)(options)) {    leading = !!options.leading;    maxing = 'maxWait' in options;    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;    trailing = 'trailing' in options ? !!options.trailing : trailing;  }  function invokeFunc(time) {    var args = lastArgs;    var thisArg = lastThis;    lastArgs = lastThis = undefined;    lastInvokeTime = time;    result = func.apply(thisArg, args);    return result;  }  function startTimer(pendingFunc, wait) {    if (useRAF) {      _root.default.cancelAnimationFrame(timerId);      return _root.default.requestAnimationFrame(pendingFunc);    }    return setTimeout(pendingFunc, wait);  }  function cancelTimer(id) {    if (useRAF) {      return _root.default.cancelAnimationFrame(id);    }    clearTimeout(id);  }  function leadingEdge(time) {    // Reset any `maxWait` timer.    lastInvokeTime = time; // Start the timer for the trailing edge.    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.    return leading ? invokeFunc(time) : result;  }  function remainingWait(time) {    var timeSinceLastCall = time - lastCallTime;    var timeSinceLastInvoke = time - lastInvokeTime;    var timeWaiting = wait - timeSinceLastCall;    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;  }  function shouldInvoke(time) {    var timeSinceLastCall = time - lastCallTime;    var timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the    // trailing edge, the system time has gone backwards and we're treating    // it as the trailing edge, or we've hit the `maxWait` limit.    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;  }  function timerExpired() {    var time = Date.now();    if (shouldInvoke(time)) {      return trailingEdge(time);    } // Restart the timer.    timerId = startTimer(timerExpired, remainingWait(time));  }  function trailingEdge(time) {    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been    // debounced at least once.    if (trailing && lastArgs) {      return invokeFunc(time);    }    lastArgs = lastThis = undefined;    return result;  }  function cancel() {    if (timerId !== undefined) {      cancelTimer(timerId);    }    lastInvokeTime = 0;    lastArgs = lastCallTime = lastThis = timerId = undefined;  }  function flush() {    return timerId === undefined ? result : trailingEdge(Date.now());  }  function pending() {    return timerId !== undefined;  }  function debounced() {    var time = Date.now();    var isInvoking = shouldInvoke(time);    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {      args[_key] = arguments[_key];    }    lastArgs = args;    lastThis = this;    lastCallTime = time;    if (isInvoking) {      if (timerId === undefined) {        return leadingEdge(lastCallTime);      }      if (maxing) {        // Handle invocations in a tight loop.        timerId = startTimer(timerExpired, wait);        return invokeFunc(lastCallTime);      }    }    if (timerId === undefined) {      timerId = startTimer(timerExpired, wait);    }    return result;  }  debounced.cancel = cancel;  debounced.flush = flush;  debounced.pending = pending;  return debounced;}
"use strict";var lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
"use strict";var lastInvokeTime = 0;
"use strict";var leading = false;
"use strict";var maxing = false;
"use strict";var trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
"use strict";// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.var useRAF = !wait && wait !== 0 && typeof _root.default.requestAnimationFrame === 'function';
"use strict";function invokeFunc(time) {  var args = lastArgs;  var thisArg = lastThis;  lastArgs = lastThis = undefined;  lastInvokeTime = time;  result = func.apply(thisArg, args);  return result;}
"use strict";var args = lastArgs;
"use strict";var thisArg = lastThis;
"use strict";function startTimer(pendingFunc, wait) {  if (useRAF) {    _root.default.cancelAnimationFrame(timerId);    return _root.default.requestAnimationFrame(pendingFunc);  }  return setTimeout(pendingFunc, wait);}
"use strict";function cancelTimer(id) {  if (useRAF) {    return _root.default.cancelAnimationFrame(id);  }  clearTimeout(id);}
"use strict";function leadingEdge(time) {  // Reset any `maxWait` timer.  lastInvokeTime = time; // Start the timer for the trailing edge.  timerId = startTimer(timerExpired, wait); // Invoke the leading edge.  return leading ? invokeFunc(time) : result;}
"use strict";function remainingWait(time) {  var timeSinceLastCall = time - lastCallTime;  var timeSinceLastInvoke = time - lastInvokeTime;  var timeWaiting = wait - timeSinceLastCall;  return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;}
"use strict";var timeSinceLastCall = time - lastCallTime;
"use strict";var timeSinceLastInvoke = time - lastInvokeTime;
"use strict";var timeWaiting = wait - timeSinceLastCall;
"use strict";function shouldInvoke(time) {  var timeSinceLastCall = time - lastCallTime;  var timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the  // trailing edge, the system time has gone backwards and we're treating  // it as the trailing edge, or we've hit the `maxWait` limit.  return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;}
"use strict";var timeSinceLastCall = time - lastCallTime;
"use strict";var timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the// trailing edge, the system time has gone backwards and we're treating// it as the trailing edge, or we've hit the `maxWait` limit.
"use strict";function timerExpired() {  var time = Date.now();  if (shouldInvoke(time)) {    return trailingEdge(time);  } // Restart the timer.  timerId = startTimer(timerExpired, remainingWait(time));}
"use strict";var time = Date.now();
"use strict";function trailingEdge(time) {  timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been  // debounced at least once.  if (trailing && lastArgs) {    return invokeFunc(time);  }  lastArgs = lastThis = undefined;  return result;}
"use strict";function cancel() {  if (timerId !== undefined) {    cancelTimer(timerId);  }  lastInvokeTime = 0;  lastArgs = lastCallTime = lastThis = timerId = undefined;}
"use strict";function flush() {  return timerId === undefined ? result : trailingEdge(Date.now());}
"use strict";function pending() {  return timerId !== undefined;}
"use strict";function debounced() {  var time = Date.now();  var isInvoking = shouldInvoke(time);  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {    args[_key] = arguments[_key];  }  lastArgs = args;  lastThis = this;  lastCallTime = time;  if (isInvoking) {    if (timerId === undefined) {      return leadingEdge(lastCallTime);    }    if (maxing) {      // Handle invocations in a tight loop.      timerId = startTimer(timerExpired, wait);      return invokeFunc(lastCallTime);    }  }  if (timerId === undefined) {    timerId = startTimer(timerExpired, wait);  }  return result;}
"use strict";var time = Date.now();
"use strict";var isInvoking = shouldInvoke(time);
"use strict";var _len = arguments.length,    args = new Array(_len),    _key = 0;
"use strict";var _default = debounce;
"use strict";var _deburrLetter = _interopRequireDefault(require("./.internal/deburrLetter.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to compose unicode character classes. */
"use strict";/** Used to compose unicode character classes. */var rsComboMarksRange = '\\u0300-\\u036f';
"use strict";var reComboHalfMarksRange = '\\ufe20-\\ufe2f';
"use strict";var rsComboSymbolsRange = '\\u20d0-\\u20ff';
"use strict";var rsComboMarksExtendedRange = '\\u1ab0-\\u1aff';
"use strict";var rsComboMarksSupplementRange = '\\u1dc0-\\u1dff';
"use strict";var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;/** Used to compose unicode capture groups. */
"use strict";/** Used to compose unicode capture groups. */var rsCombo = "[".concat(rsComboRange, "]");/** * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols). */
"use strict";/** * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols). */var reComboMark = RegExp(rsCombo, 'g');/** * Deburrs `string` by converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @since 3.0.0 * @category String * @param {string} [string=''] The string to deburr. * @returns {string} Returns the deburred string. * @example * * deburr('dj vu') * // => 'deja vu' */
"use strict";/** * Deburrs `string` by converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @since 3.0.0 * @category String * @param {string} [string=''] The string to deburr. * @returns {string} Returns the deburred string. * @example * * deburr('dj vu') * // => 'deja vu' */function deburr(string) {  return string && string.replace(reLatin, _deburrLetter.default).replace(reComboMark, '');}
"use strict";var _default = deburr;
"use strict";/** * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * defaultTo(1, 10) * // => 1 * * defaultTo(undefined, 10) * // => 10 */function defaultTo(value, defaultValue) {  return value == null || value !== value ? defaultValue : value;}
"use strict";var _default = defaultTo;
"use strict";var _arrayReduce = _interopRequireDefault(require("./.internal/arrayReduce.js"));
"use strict";var _defaultTo = _interopRequireDefault(require("./defaultTo.js"));
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";/** * This method is like `defaultTo` except that it accepts multiple default values and returns the first one that is not * `NaN`, `null`, or `undefined`. * * @since 5.0.0 * @category Util * @param {*} value The value to check. * @param {...*} defaultValues The default values. * @returns {*} Returns the resolved value. * @see _.defaultTo * @example * * defaultToAny(1, 10, 20) * // => 1 * * defaultToAny(undefined, 10, 20) * // => 10 * * defaultToAny(undefined, null, 20) * // => 20 * * defaultToAny(undefined, null, NaN) * // => NaN */function defaultToAny(value) {  for (var _len = arguments.length, defaultValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {    defaultValues[_key - 1] = arguments[_key];  }  return (0, _arrayReduce.default)(defaultValues, _defaultTo.default, value);}
"use strict";var _len = arguments.length,    defaultValues = new Array(_len > 1 ? _len - 1 : 0),    _key = 1;
"use strict";var _default = defaultToAny;
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
"use strict";function _interopRequireDefault(obj) {  return obj && obj.__esModule ? obj : {    default: obj  };}
